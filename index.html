<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brückenbau-Anleitung für Klasse 9</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js for 3D graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Google Fonts for better typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Liquid Glass Effect & Background Animation --- */
        body { 
            font-family: 'Inter', sans-serif; 
            scroll-behavior: smooth;
            background-color: #0f172a; /* Dark blue background */
            color: #e2e8f0; /* Light text color for contrast */
            overflow-x: hidden; /* Prevent horizontal scroll from blobs */
        }

        /* Animated blobs in the background */
        .background-blob {
            position: absolute;
            border-radius: 9999px; /* Make it a circle */
            filter: blur(100px); /* Heavy blur for a soft effect */
            z-index: -10; /* Place it behind all content */
        }

        .blob-1 {
            width: 400px;
            height: 400px;
            background: linear-gradient(180deg, rgba(59, 130, 246, 0.4), rgba(37, 99, 235, 0.6));
            top: -150px;
            left: -150px;
            animation: move 25s infinite alternate;
        }

        .blob-2 {
            width: 500px;
            height: 500px;
            background: linear-gradient(180deg, rgba(139, 92, 246, 0.4), rgba(124, 58, 237, 0.6));
            bottom: -200px;
            right: -200px;
            animation: move 30s infinite alternate;
        }

        @keyframes move {
            from {
                transform: translate(0, 0) rotate(0deg);
            }
            to {
                transform: translate(100px, 50px) rotate(180deg);
            }
        }
        
        /* The main class for the glass effect panels */
        .glass-panel {
            background: rgba(255, 255, 255, 0.05); /* Very transparent white */
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px); /* For Safari */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.2); /* Soft shadow */
        }
        
        /* Style for the 3D canvas container */
        #bridgeCanvasContainer {
            min-height: 400px;
            cursor: grab;
            border-radius: 0.5rem;
            background: transparent; /* Make canvas container transparent */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-200">
    <!-- Background Blobs for the liquid effect -->
    <div class="background-blob blob-1"></div>
    <div class="background-blob blob-2"></div>

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 relative z-10">
        
        <!-- Header Section -->
        <header class="text-center mb-10">
            <h1 class="text-3xl md:text-5xl font-bold text-white mb-2">
                Faszination Brückenbau
            </h1>
            <p class="text-lg md:text-xl text-slate-400">Eine Anleitung für Schüler der 9. Klasse</p>
        </header>

        <!-- Main Content Grid -->
        <main class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            
            <!-- Left Column: 3D Model -->
            <div class="glass-panel p-6 flex flex-col">
                <h2 class="text-2xl font-bold text-blue-400 mb-3">Interaktives 3D-Modell</h2>
                <p class="mb-4 text-slate-300">
                    Wähle eine Ansicht, um die Struktur der Brücke zu erkunden. Halte die Maustaste gedrückt und bewege die Maus, um das Modell zu drehen.
                </p>
                <!-- Model Switcher -->
                <div class="flex justify-center space-x-4 mb-4">
                    <button id="wireframeBtn" class="px-4 py-2 rounded-lg bg-blue-500 text-white font-semibold transition-transform transform hover:scale-105">Drahtmodell</button>
                    <button id="solidBtn" class="px-4 py-2 rounded-lg bg-slate-600 text-white font-semibold transition-transform transform hover:scale-105">Festkörpermodell</button>
                </div>
                <!-- Container for the 3D Canvas -->
                <div id="bridgeCanvasContainer" class="w-full h-96 flex-grow">
                    <!-- The 3D canvas will be inserted here -->
                </div>
            </div>

            <!-- Right Column: Explanations -->
            <div class="glass-panel p-6 space-y-6">
                <div>
                    <h2 class="text-2xl font-bold text-blue-400 mb-3">Das Geheimnis der Stabilität</h2>
                    <p class="text-slate-300">
                        Brücken sind Meisterwerke der Ingenieurskunst. Ihr Ziel ist es, Lasten sicher über ein Hindernis zu tragen. Die größte Herausforderung sind zwei Kräfte: <span class="font-semibold text-red-400">Druck</span> und <span class="font-semibold text-green-400">Zug</span>.
                    </p>
                </div>
                <div>
                    <h3 class="text-xl font-bold text-white mb-2">Das Dreieck: Die stabilste Form</h3>
                    <p class="text-slate-300">
                        Eine Fachwerkbrücke nutzt die unglaubliche Stabilität von Dreiecken. Ein Viereck verformt sich leicht. Ein Dreieck hingegen ist starr. Diese Eigenschaft macht es extrem stabil, da die Kräfte durch die Stäbe auf die Pfeiler abgeleitet werden.
                    </p>
                </div>
                 <div>
                    <h3 class="text-xl font-bold text-white mb-2">Andere Brückentypen</h3>
                    <ul class="list-disc list-inside space-y-2 text-slate-300">
                        <li><strong>Balkenbrücke:</strong> Die einfachste Form. Ein Balken auf zwei Pfeilern.</li>
                        <li><strong>Bogenbrücke:</strong> Der Bogen leitet die Druckkräfte perfekt in die Fundamente ab.</li>
                        <li><strong>Hängebrücke:</strong> Für sehr weite Strecken. Dicke Stahlseile tragen die Fahrbahn.</li>
                    </ul>
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        const container = document.getElementById('bridgeCanvasContainer');
        const wireframeBtn = document.getElementById('wireframeBtn');
        const solidBtn = document.getElementById('solidBtn');

        if (!container || !wireframeBtn || !solidBtn) {
            console.error("Ein benötigtes HTML-Element wurde nicht gefunden!");
        }

        // --- Basic Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 4, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0); // Transparent background
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(8, 10, 5);
        scene.add(directionalLight);

        // --- Parent Group for Rotation ---
        const masterGroup = new THREE.Group();
        scene.add(masterGroup);
        
        // --- Bridge Geometry Data ---
        const vertices = [
            new THREE.Vector3(-8, 0, -1), new THREE.Vector3(-4, 0, -1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(4, 0, -1), new THREE.Vector3(8, 0, -1),
            new THREE.Vector3(-8, 0, 1), new THREE.Vector3(-4, 0, 1), new THREE.Vector3(0, 0, 1), new THREE.Vector3(4, 0, 1), new THREE.Vector3(8, 0, 1),
            new THREE.Vector3(-6, 3, -1), new THREE.Vector3(-2, 3, -1), new THREE.Vector3(2, 3, -1), new THREE.Vector3(6, 3, -1),
            new THREE.Vector3(-6, 3, 1), new THREE.Vector3(-2, 3, 1), new THREE.Vector3(2, 3, 1), new THREE.Vector3(6, 3, 1),
        ];

        const lineIndices = [
            0,1, 1,2, 2,3, 3,4, 5,6, 6,7, 7,8, 8,9, 0,5, 1,6, 2,7, 3,8, 4,9, 10,11, 11,12, 12,13, 14,15, 15,16, 16,17,
            10,14, 11,15, 12,16, 13,17, 1,10, 6,14, 2,11, 7,15, 3,12, 8,16, 4,13, 9,17, 0,10, 1,11, 2,12, 3,13, 5,14, 
            6,15, 7,16, 8,17, 10,2, 11,3, 12,4, 14,7, 15,8, 16,9
        ];

        // --- Model 1: Wireframe ---
        const wireframeGroup = new THREE.Group();
        const pointsGeometry = new THREE.BufferGeometry().setFromPoints(vertices);
        const pointsMaterial = new THREE.PointsMaterial({ color: 0x60a5fa, size: 0.3 });
        wireframeGroup.add(new THREE.Points(pointsGeometry, pointsMaterial));
        const lineGeometry = new THREE.BufferGeometry();
        const linePositions = [];
        lineIndices.forEach(index => linePositions.push(vertices[index].x, vertices[index].y, vertices[index].z));
        lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x94a3b8 });
        wireframeGroup.add(new THREE.LineSegments(lineGeometry, lineMaterial));
        masterGroup.add(wireframeGroup);

        // --- Model 2: Solid Body ---
        const solidGroup = new THREE.Group();
        const nodeMaterial = new THREE.MeshStandardMaterial({ color: 0x3b82f6, roughness: 0.4, metalness: 0.1 });
        const beamMaterial = new THREE.MeshStandardMaterial({ color: 0x9ca3af, roughness: 0.8, metalness: 0.2 });
        const nodeGeometry = new THREE.SphereGeometry(0.25, 16, 16);
        
        vertices.forEach(vertex => {
            const nodeMesh = new THREE.Mesh(nodeGeometry, nodeMaterial);
            nodeMesh.position.copy(vertex);
            solidGroup.add(nodeMesh);
        });

        const beamRadius = 0.1;
        for (let i = 0; i < lineIndices.length; i += 2) {
            const startPoint = vertices[lineIndices[i]];
            const endPoint = vertices[lineIndices[i+1]];
            
            const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
            const beamLength = direction.length();
            const beamGeometry = new THREE.CylinderGeometry(beamRadius, beamRadius, beamLength, 12);
            
            const beamMesh = new THREE.Mesh(beamGeometry, beamMaterial);
            beamMesh.position.copy(startPoint).add(direction.multiplyScalar(0.5));
            beamMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.normalize());
            solidGroup.add(beamMesh);
        }
        solidGroup.visible = false;
        masterGroup.add(solidGroup);

        // --- Controls & Interaction ---
        wireframeBtn.addEventListener('click', () => {
            wireframeGroup.visible = true;
            solidGroup.visible = false;
            wireframeBtn.classList.replace('bg-slate-600', 'bg-blue-500');
            solidBtn.classList.replace('bg-blue-500', 'bg-slate-600');
        });

        solidBtn.addEventListener('click', () => {
            wireframeGroup.visible = false;
            solidGroup.visible = true;
            solidBtn.classList.replace('bg-slate-600', 'bg-blue-500');
            wireframeBtn.classList.replace('bg-blue-500', 'bg-slate-600');
        });

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        container.addEventListener('mousedown', (e) => { isDragging = true; container.style.cursor = 'grabbing'; });
        container.addEventListener('mouseup', () => { isDragging = false; container.style.cursor = 'grab'; });
        container.addEventListener('mouseleave', () => { isDragging = false; container.style.cursor = 'grab'; });
        container.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const deltaMove = { x: e.offsetX - previousMousePosition.x, y: e.offsetY - previousMousePosition.y };
            masterGroup.rotation.y += deltaMove.x * 0.005;
            masterGroup.rotation.x += deltaMove.y * 0.005;
            previousMousePosition = { x: e.offsetX, y: e.offsetY };
        });

        // --- Animation & Resizing ---
        function animate() {
            requestAnimationFrame(animate);
            if (!isDragging) { masterGroup.rotation.y += 0.002; }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }, false);
    </script>
</body>
</html>
