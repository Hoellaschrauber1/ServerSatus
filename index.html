<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortnite Status & Community Hub</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>

    <style>
        /* Custom styles for a modern, gaming-inspired look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0F172A; /* Darker blue */
            color: #E5E7EB;
            overflow: hidden;
        }

        /* Starry background effect */
        .stars {
            background: #0F172A url(data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjEwMHB4IiBoZWlnaHQ9IjEwMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+ICA8Y2lyY2xlIGZpbGw9IiNGRkZGRkYiIGN4PSIyMyIgaWQ9InN0YXIxIiBjeT0iMjMiIHI9IjAuNSIvPiAgPGNpcmNsZSBmaWxsPSIjRkZGRkZGIiBjeD0iMzMiIGlkPSJzdGFyMiIgY3k9IjMzIiByPSIwLjUiLz4gIDxjaXJjbGUgZmlsbD0iI0ZGRkZGRiIgY3g9IjQ1IiBpZD0ic3RhcjMiIGN5PSI0NSIgcj0iMC41Ii8+ICA8Y2lyY2xlIGZpbGw9IiNGRkZGRkYiIGN4PSI1MiIgaWQ9InN0YXI0IiBjeT0iNTIiIHI9IjAuNSIvPiAgPGNpcmNsZSBmaWxsPSIjRkZGRkZGIiBjeD0iODciIGlkPSJzdGFyNSIgY3k9Ijg3IiByPSIwLjUiLz4gIDxjaXJjbGUgZmlsbD0iI0ZGRkZGRiIgY3g9Ijc1IiBpZD0ic3RhcjYiIGN5PSI3NSIgcj0iMC41Ii8+ICA8Y2lyY2xlIGZpbGw9IiNGRkZGRkYiIGN4PSI5MiIgaWQ9InN0YXI3IiBjeT0iOTEiIHI9IjAuNSIvPiAgPGNpcmNsZSBmaWxsPSIjRkZGRkZGIiBjeD0iMTIiIGlkPSJzdGFyOCIgY3k9IjEyIiByPSIwLjUiLz4gIDxjaXJjbGUgZmlsbD0iI0ZGRkZGRiIgY3g9IjQwIiBpZD0ic3RhcjkiIGN5PSI4IiByPSIwLjUiLz4gIDxjaXJjbGUgZmlsbD0iI0ZGRkZGRiIgY3g9Ijg4IiBpZD0ic3RhcjEwIiBjeT0iMyIgcj0iMC41Ii8+ICA8Y2lyY2xlIGZpbGw9IiNGRkZGRkYiIGN4PSI5OCIgaWQ9InN0YXIxMSIgY3k9IjUiIHI9IjAuNSIvPiAgPGNpcmNsZSBmaWxsPSIjRkZGRkZGIiBjeD0iOTMiIGlkPSJzdGFyMTIiIGN5PSI5MyIgcj0iMC41Ii8+PC9zdmc+) repeat;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: -1;
            animation: move-stars 200s linear infinite;
        }

        @keyframes move-stars {
            from { background-position: 0 0; }
            to { background-position: -10000px 5000px; }
        }

        /* Glassmorphism effect for modals and cards */
        .glass-card {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
        }

        /* Animation for modals */
        .modal-enter { animation: fadeIn 0.3s ease-out forwards; }
        .modal-leave { animation: fadeOut 0.3s ease-in forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        @keyframes fadeOut { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(0.95); } }

        /* Custom button styles */
        .btn-primary { @apply bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg transform transition-all duration-300; }
        .btn-primary:hover { @apply bg-blue-500 scale-105 shadow-blue-500/50; }
        .btn-secondary { @apply bg-slate-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transform transition-all duration-300; }
        .btn-secondary:hover { @apply bg-slate-600 scale-105; }
        
        /* Loading spinner */
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3B82F6; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Recording Indicator */
        .recording-indicator {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        
    </style>
</head>
<body class="w-full h-screen">

    <div class="stars"></div>

    <div id="app-container" class="w-full h-full flex flex-col hidden">
        
        <header class="w-full p-4 flex justify-between items-center">
            <h1 id="header-title" class="text-xl font-bold text-white">Fortnite Status</h1>
            <div id="header-actions" class="flex items-center gap-4">
                </div>
        </header>

        <main id="main-content" class="flex-grow flex flex-col p-4 overflow-y-auto">
            </main>
    </div>
    
    <div id="maintenance-screen" class="w-full h-full items-center justify-center p-4 hidden">
        <div class="glass-card w-full max-w-2xl p-8 md:p-12 text-center shadow-2xl">
            <i data-lucide="wrench" class="w-16 h-16 mx-auto text-blue-400 mb-6"></i>
            <h1 class="text-3xl font-bold text-white mb-2">Wartungsarbeiten</h1>
            <p class="text-lg text-gray-300">
                Es gibt aktuell Probleme mit dieser Seite. Bitte komm sp√§ter noch einmal vorbei.
            </p>
        </div>
    </div>


    <div id="modal-backdrop" class="hidden fixed inset-0 bg-black/50 z-40"></div>
    
    <div id="auth-modal" class="hidden fixed inset-0 flex items-center justify-center z-50 p-4 modal-enter">
        <div class="glass-card w-full max-w-md p-8 shadow-2xl">
            <div class="flex justify-between items-center mb-6">
                <h2 id="auth-title" class="text-2xl font-bold text-white">Anmelden</h2>
                <button id="close-auth-modal" class="text-gray-400 hover:text-white"><i data-lucide="x"></i></button>
            </div>
            <div id="auth-content"></div>
        </div>
    </div>

    <div id="chats-friends-modal" class="hidden fixed inset-0 flex items-center justify-center z-50 p-4 modal-enter">
        <div class="glass-card w-full max-w-2xl h-[70vh] flex flex-col p-6 shadow-2xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-white">Chats & Freunde</h2>
                <button id="close-chats-friends-modal" class="text-gray-400 hover:text-white"><i data-lucide="x"></i></button>
            </div>
            <div class="border-b border-slate-700">
                <nav class="flex space-x-4">
                    <button data-tab="chats" class="tab-btn py-2 px-4 text-white border-b-2 border-blue-500 font-semibold">Chats</button>
                    <button data-tab="friends" class="tab-btn py-2 px-4 text-gray-400 border-b-2 border-transparent hover:border-gray-500">Freunde</button>
                </nav>
            </div>
            <div id="chats-friends-content" class="overflow-y-auto flex-grow mt-4"></div>
        </div>
    </div>
    
    <div id="generic-modal" class="hidden fixed inset-0 flex items-center justify-center z-50 p-4 modal-enter">
        <div class="glass-card w-full max-w-4xl h-auto max-h-[90vh] flex flex-col p-6 shadow-2xl">
            <div class="flex justify-between items-center mb-4 pb-4 border-b border-slate-700">
                <div class="flex-grow">
                    <h2 id="generic-modal-title" class="text-2xl font-bold text-white"></h2>
                    <p id="generic-modal-subtitle" class="text-sm text-gray-400"></p>
                </div>
                <div id="generic-modal-header-actions" class="flex items-center gap-2"></div>
                <button id="close-generic-modal" class="text-gray-400 hover:text-white ml-4"><i data-lucide="x"></i></button>
            </div>
            <div id="generic-modal-content" class="overflow-y-auto flex-grow"></div>
            <div id="generic-modal-footer" class="mt-4 pt-4 border-t border-slate-700"></div>
        </div>
    </div>

    <div id="loading-overlay" class="fixed inset-0 bg-black/70 z-[100] flex flex-col items-center justify-center hidden">
        <div class="loader"></div>
        <p id="loading-text" class="text-white mt-4 text-lg">Lade...</p>
    </div>

    <div id="toast" class="hidden fixed bottom-5 right-5 glass-card p-4 rounded-lg shadow-lg z-[101] flex items-center gap-3">
        <i id="toast-icon" data-lucide="check-circle" class="text-green-400"></i>
        <p id="toast-message"></p>
    </div>

    <div id="message-context-menu" class="hidden absolute z-[60] glass-card p-1 rounded-lg">
        <button id="delete-context-btn" class="flex items-center gap-2 text-sm text-red-400 hover:bg-red-500/20 px-3 py-1 rounded-md w-full">
            <i data-lucide="trash-2" class="w-4 h-4"></i>
            <span>L√∂schen</span>
        </button>
        <button id="report-context-btn" class="flex items-center gap-2 text-sm text-yellow-400 hover:bg-yellow-500/20 px-3 py-1 rounded-md w-full">
            <i data-lucide="flag" class="w-4 h-4"></i>
            <span>Melden</span>
        </button>
    </div>

    <div id="chat-picker-popover" class="hidden fixed z-[60] glass-card p-2 rounded-lg w-full max-w-sm top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
        </div>

    <div id="mention-popover" class="hidden absolute z-[60] glass-card p-1 rounded-lg w-64 max-h-48 overflow-y-auto">
        </div>
    
    <div id="reaction-picker-popover" class="hidden absolute z-[60] glass-card p-2 rounded-full flex gap-1 shadow-lg">
        </div>

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getDatabase, ref as dbRef, onValue, set, onDisconnect, serverTimestamp as rtdbServerTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";
        import { getStorage, ref as storageRef, getDownloadURL, uploadBytesResumable, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";
        import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, updateProfile, deleteUser, sendEmailVerification, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, getDocs, collection, writeBatch, serverTimestamp, query, where, onSnapshot, updateDoc, arrayUnion, arrayRemove, addDoc, orderBy, deleteDoc, increment, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyB3Fqc0P3TmSb80GupZrXONZiejStgk6TE",
            authDomain: "social-media-1711a.firebaseapp.com",
            projectId: "social-media-1711a",
            storageBucket: "social-media-1711a.appspot.com",
            messagingSenderId: "228987477362",
            appId: "1:228987477362:web:0aa477a08b4d14572e51eb",
            measurementId: "G-SNQC7S4CJB",
            databaseURL: "https://social-media-1711a-default-rtdb.europe-west1.firebasedatabase.app"
        };

        // --- APP INITIALIZATION ---
        let app, auth, db, rtdb, storage;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            rtdb = getDatabase(app);
            storage = getStorage(app);
        } catch (e) {
            document.getElementById('main-content').innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold text-red-500">Fehler bei der Firebase-Initialisierung!</h2><p class="mt-2 text-gray-400">Fehler: ${e.message}</p></div>`;
            console.error("Firebase initialization failed:", e);
        }
        
        const appId = 'fortnite-social-app';

        // --- GIPHY API KEY ---
        const GIPHY_API_KEY = 'BAE8RypYNwugJzhT1oMmqbWMHujifiuf';


        // --- DOM ELEMENT REFERENCES ---
        const appContainer = document.getElementById('app-container');
        const maintenanceScreen = document.getElementById('maintenance-screen');
        const mainContent = document.getElementById('main-content');
        const headerTitle = document.getElementById('header-title');
        const headerActions = document.getElementById('header-actions');
        const loadingOverlay = document.getElementById('loading-overlay');
        const modalBackdrop = document.getElementById('modal-backdrop');
        const authModal = document.getElementById('auth-modal');
        const chatsFriendsModal = document.getElementById('chats-friends-modal');
        const genericModal = document.getElementById('generic-modal');
        const pickerPopover = document.getElementById('chat-picker-popover');
        
        // --- GLOBAL STATE ---
        let currentUser = null;
        let currentUserProfile = null;
        let unsubscribeUserListener = null;
        let unsubscribeFriendStatusListener = null;
        let friendsStatusUnsubscribers = {};
        let isRegistering = false;
        let typingTimeout = null;
        let unsubscribeChatListener = null;
        let unsubscribeTypingListener = null;
        let longPressTimer = null;
        let activeChatId = null;
        let activeChatType = null;
        let activeChatGroupData = null; 
        let notificationSound;
        let previousUnreadCount = 0;
        let activePicker = null; 
        let mediaRecorder = null;
        let isRecording = false;
        let audioChunks = [];
        let inactivityTimer = null;
        const PREDEFINED_REACTIONS = ['üëç', '‚ù§Ô∏è', 'üòÇ', 'üòÆ', 'üò¢', 'üôè'];

        // --- HELPER & MODAL FUNCTIONS ---
        const showLoader = (text = 'Lade...') => {
            document.getElementById('loading-text').textContent = text;
            loadingOverlay.classList.remove('hidden');
        };
        const hideLoader = () => {
            loadingOverlay.classList.add('hidden');
        };
        const showToast = (message, type = 'success') => {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toast-message');
            const toastIcon = document.getElementById('toast-icon');
            toastMessage.textContent = message;
            toast.classList.remove('hidden');
            if (type === 'success') {
                toastIcon.setAttribute('data-lucide', 'check-circle');
                toastIcon.setAttribute('class', 'text-green-400');
            } else if (type === 'error') {
                toastIcon.setAttribute('data-lucide', 'alert-circle');
                toastIcon.setAttribute('class', 'text-red-400');
            } else {
                toastIcon.setAttribute('data-lucide', 'info');
                toastIcon.setAttribute('class', 'text-blue-400');
            }
            lucide.createIcons();
            setTimeout(() => { toast.classList.add('hidden') }, 3000);
        };
        const openModal = (modalElement) => {
            modalBackdrop.classList.remove('hidden');
            modalElement.classList.remove('hidden', 'modal-leave');
            modalElement.classList.add('modal-enter');
        };
        const closeModal = (modalElement) => {
            modalElement.classList.remove('modal-enter');
            modalElement.classList.add('modal-leave');
            setTimeout(() => {
                modalElement.classList.add('hidden');
                if (!document.querySelector('.modal-enter:not(.hidden)')) {
                    modalBackdrop.classList.add('hidden');
                }
            }, 300);
        };
        const showConfirmationModal = (message, onConfirm) => {
            const modalTitle = document.getElementById('generic-modal-title');
            const modalSubtitle = document.getElementById('generic-modal-subtitle');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            const modalHeaderActions = document.getElementById('generic-modal-header-actions');
            modalTitle.textContent = 'Best√§tigung';
            modalSubtitle.textContent = '';
            modalHeaderActions.innerHTML = '';
            modalContent.innerHTML = `<p class="text-gray-300">${message}</p>`;
            modalFooter.innerHTML = `
                <div class="flex justify-end gap-4">
                    <button id="confirm-cancel-btn" class="btn-secondary">Abbrechen</button>
                    <button id="confirm-ok-btn" class="btn-primary bg-red-600 hover:bg-red-500">Best√§tigen</button>
                </div>
            `;
            openModal(genericModal);
            document.getElementById('confirm-ok-btn').onclick = () => { onConfirm(); closeModal(genericModal); };
            document.getElementById('confirm-cancel-btn').onclick = () => closeModal(genericModal);
        };

        const linkify = (inputText) => {
            if (!inputText) return '';
            
            const mentionPattern = /@(\w+)/g;
            let linkedText = inputText.replace(mentionPattern, (match, username) => {
                if (activeChatType === 'group' && activeChatGroupData && activeChatGroupData.memberDetails) {
                    const mentionedUser = Object.values(activeChatGroupData.memberDetails).find(m => m.displayName === username);
                    if (mentionedUser) {
                        if (mentionedUser.id === currentUser.uid) {
                             return `<span class="bg-yellow-500/30 text-yellow-200 font-bold p-1 rounded-md">@${username}</span>`;
                        }
                        return `<span class="text-blue-400 font-bold">@${username}</span>`;
                    }
                }
                return match;
            });

            const urlPattern = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
            linkedText = linkedText.replace(urlPattern, '<a href="$1" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline">$1</a>');

            const wwwPattern = /(^|[^\/])(www\.[\S]+(\b|$))/gim;
            linkedText = linkedText.replace(wwwPattern, '$1<a href="http://$2" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline">$2</a>');

            return linkedText;
        };
        
        const formatLastSeen = (timestamp) => {
            if (!timestamp) return 'Unbekannt';
            const now = new Date();
            const lastSeenDate = timestamp.toDate();
            const diffSeconds = Math.round((now - lastSeenDate) / 1000);
            const diffMinutes = Math.round(diffSeconds / 60);
            const diffHours = Math.round(diffMinutes / 60);
            const diffDays = Math.round(diffHours / 24);

            if (diffSeconds < 60) return `gerade eben`;
            if (diffMinutes < 60) return `vor ${diffMinutes} Min.`;
            if (diffHours < 24) return `vor ${diffHours} Std.`;
            if (diffDays === 1) return `Gestern um ${lastSeenDate.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })}`;
            return `am ${lastSeenDate.toLocaleDateString('de-DE')}`;
        };


        // --- ADMIN & REPORTING FUNCTIONS ---
        const showReportModal = (contentId, contentType, context = {}) => {
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            if (contentType === 'user') {
                 modalTitle.textContent = `Nutzer "${context.userName}" melden`;
            } else {
                 modalTitle.textContent = 'Inhalt melden';
            }
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `
                <div class="space-y-4">
                    <div>
                        <label for="report-reason" class="block text-sm font-medium text-gray-300 mb-1">Grund f√ºr die Meldung</label>
                        <select id="report-reason" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg">
                            <option>Spam oder irref√ºhrend</option>
                            <option>Hassrede oder Bel√§stigung</option>
                            <option>Gewaltt√§tige oder absto√üende Inhalte</option>
                            <option>Nacktheit oder sexuelle Inhalte</option>
                            <option>Sonstiges</option>
                        </select>
                    </div>
                    <div>
                        <label for="report-details" class="block text-sm font-medium text-gray-300 mb-1">Zus√§tzliche Details (optional)</label>
                        <textarea id="report-details" rows="4" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg" placeholder="Bitte gib mehr Informationen an..."></textarea>
                    </div>
                </div>
            `;
            modalFooter.innerHTML = `<button id="submit-report-btn" class="btn-primary bg-red-600 hover:bg-red-500 w-full">Meldung abschicken</button>`;
            openModal(genericModal);

            document.getElementById('submit-report-btn').addEventListener('click', () => {
                const reason = document.getElementById('report-reason').value;
                const details = document.getElementById('report-details').value;
                handleReportSubmit(contentId, contentType, reason, details, context);
            });
        };

        const handleReportSubmit = async (contentId, contentType, reason, details, context) => {
            if (!currentUser) {
                showToast("Du musst angemeldet sein, um Inhalte zu melden.", "error");
                return;
            }
            showLoader("Meldung wird gesendet...");
            try {
                await addDoc(collection(db, 'reports'), {
                    reporterId: currentUser.uid,
                    reporterName: currentUserProfile.displayName,
                    contentId,
                    contentType,
                    reason,
                    details,
                    context, 
                    status: 'open',
                    timestamp: serverTimestamp()
                });
                showToast("Meldung erfolgreich √ºbermittelt. Vielen Dank!", "success");
                closeModal(genericModal);
            } catch (error) {
                console.error("Error submitting report:", error);
                showToast("Fehler beim Senden der Meldung.", "error");
            } finally {
                hideLoader();
            }
        };
        
        const renderAdminUsers = async () => {
            const adminContentArea = document.getElementById('admin-content-area');
            if (!adminContentArea) return;
            adminContentArea.innerHTML = '<div class="loader"></div>';

            try {
                const usersRef = collection(db, "users");
                const querySnapshot = await getDocs(usersRef);
                let userCardsHtml = '';
                querySnapshot.forEach(doc => {
                    const user = {id: doc.id, ...doc.data()};
                    if (user.id === currentUser.uid) return;
                    
                    const crownIcon = user.role === 'founder' || user.role === 'admin' ? `<i data-lucide="crown" class="w-5 h-5 text-yellow-400"></i>` : '';
                    let adminDateHtml = '';
                    if (user.role === 'admin' && user.promotedToAdminAt) {
                        const date = user.promotedToAdminAt.toDate().toLocaleDateString('de-DE');
                        adminDateHtml = `<p class="text-xs text-gray-400 mt-1">Admin seit: ${date}</p>`;
                    }
                    
                    let adminButtonHtml = '';
                    if (user.role === 'founder') {
                        adminButtonHtml = `<button class="btn-secondary text-sm flex-grow opacity-50 cursor-not-allowed" disabled>Gr√ºnder</button>`;
                    } else {
                        adminButtonHtml = `<button data-id="${user.id}" data-role="${user.role}" class="toggle-admin-btn btn-secondary text-sm flex-grow ${currentUserProfile.role !== 'founder' ? 'opacity-50 cursor-not-allowed' : ''}" ${currentUserProfile.role !== 'founder' ? 'disabled' : ''}>${user.role === 'admin' ? 'Admin entfernen' : 'Admin geben'}</button>`;
                    }

                    let banButtonHtml = '';
                    if (user.role === 'founder') {
                        banButtonHtml = `<button class="bg-slate-800 text-gray-500 font-bold py-2 px-4 rounded-lg text-sm flex-grow cursor-not-allowed" disabled>Unantastbar</button>`;
                    } else {
                        banButtonHtml = `<button data-id="${user.id}" data-banned="${user.banned}" class="toggle-ban-btn ${user.banned ? 'bg-green-600 hover:bg-green-500' : 'bg-red-600 hover:bg-red-500'} text-white font-bold py-2 px-4 rounded-lg text-sm flex-grow">${user.banned ? 'Entsperren' : 'Sperren'}</button>`;
                    }

                    let verifyButtonHtml = '';
                    if (!user.emailVerified && !user.isManuallyVerified && (currentUserProfile.role === 'admin' || currentUserProfile.role === 'founder')) {
                        verifyButtonHtml = `<button data-id="${user.id}" class="manual-verify-btn btn-secondary bg-green-600 hover:bg-green-500 text-sm flex-grow">Verifizieren</button>`;
                    }


                    userCardsHtml += `
                        <div class="glass-card p-4 rounded-lg mb-4">
                            <div class="flex justify-between items-start">
                                <div class="flex items-center gap-3">
                                    <img src="${user.photoURL || `https://placehold.co/48x48/1E293B/FFFFFF?text=${user.displayName.charAt(0)}`}" class="w-12 h-12 rounded-full object-cover">
                                    <div>
                                        <p class="font-bold text-lg flex items-center gap-2">${user.displayName} ${crownIcon}</p>
                                        <p class="text-sm text-gray-400">${user.email}</p>
                                        ${adminDateHtml}
                                    </div>
                                </div>
                                <div class="text-right">
                                    <p class="text-sm text-gray-400">Bans: ${user.banCount || 0}</p>
                                </div>
                            </div>
                            <div class="mt-4 pt-4 border-t border-slate-700 flex gap-2">
                                ${adminButtonHtml}
                                ${banButtonHtml}
                                ${verifyButtonHtml}
                            </div>
                        </div>
                    `;
                });
                adminContentArea.innerHTML = `<div class="space-y-4">${userCardsHtml}</div>`;
                lucide.createIcons();
                adminContentArea.querySelectorAll('.toggle-admin-btn').forEach(btn => { btn.addEventListener('click', () => toggleAdminRole(btn.dataset.id, btn.dataset.role)); });
                adminContentArea.querySelectorAll('.toggle-ban-btn').forEach(btn => { btn.addEventListener('click', () => toggleBanStatus(btn.dataset.id, btn.dataset.banned === 'true')); });
                adminContentArea.querySelectorAll('.manual-verify-btn').forEach(btn => { btn.addEventListener('click', () => handleManualVerify(btn.dataset.id)); });
            } catch (error) {
                console.error("Error fetching users for admin panel:", error);
                adminContentArea.innerHTML = `<div class="text-center p-4"><p class="text-red-400">Fehler beim Laden der Benutzerliste.</p><p class="text-gray-400 mt-2 text-sm">Dies liegt wahrscheinlich an den Firestore-Sicherheitsregeln. Administratoren ben√∂tigen eine "list"-Berechtigung f√ºr die "users"-Sammlung, um alle Benutzer anzuzeigen.</p></div>`;
            }
        };

        const handleManualVerify = async (userId) => {
            showConfirmationModal('M√∂chtest du diesen Nutzer wirklich manuell verifizieren?', async () => {
                showLoader('Verifiziere Nutzer...');
                try {
                    const userRef = doc(db, 'users', userId);
                    await updateDoc(userRef, { isManuallyVerified: true });
                    showToast('Nutzer erfolgreich verifiziert.', 'success');
                    renderAdminUsers(); 
                } catch (error) {
                    console.error("Error manually verifying user:", error);
                    showToast('Fehler bei der manuellen Verifizierung.', 'error');
                } finally {
                    hideLoader();
                }
            });
        };

        const renderAdminReports = async () => {
            const adminContentArea = document.getElementById('admin-content-area');
            if (!adminContentArea) return;
            adminContentArea.innerHTML = '<div class="loader"></div>';

            try {
                const reportsQuery = query(collection(db, "reports"), where('status', '==', 'open'));
                const snapshot = await getDocs(reportsQuery);
                
                if (snapshot.empty) {
                    adminContentArea.innerHTML = `<p class="text-center text-gray-400">Keine offenen Meldungen.</p>`;
                    return;
                }

                const reports = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                reports.sort((a, b) => (b.timestamp?.toMillis() || 0) - (a.timestamp?.toMillis() || 0));

                let reportsHtml = '';
                for (const report of reports) {
                    let reportedContentInfo = `Gemeldeter Inhalt: ${report.contentType} (${report.contentId.substring(0, 8)}...)`;
                    if(report.contentType === 'user' && report.context?.userName) {
                        reportedContentInfo = `Gemeldeter Nutzer: <strong>${report.context.userName}</strong>`;
                    }

                    reportsHtml += `
                        <div class="glass-card p-4 rounded-lg mb-4">
                            <div class="flex justify-between items-start">
                                <div>
                                    <p class="font-bold text-yellow-400">${report.reason}</p>
                                    <p class="text-sm text-gray-300">${reportedContentInfo}</p>
                                    <p class="text-sm text-gray-400">Gemeldet von: ${report.reporterName}</p>
                                    <p class="text-sm text-gray-500 mt-2">${report.details || 'Keine weiteren Details.'}</p>
                                </div>
                                <span class="text-xs text-gray-500">${report.timestamp.toDate().toLocaleString('de-DE')}</span>
                            </div>
                            <div class="mt-4 pt-4 border-t border-slate-700 flex gap-2">
                                <button data-report-id="${report.id}" class="resolve-report-btn btn-secondary bg-green-600 hover:bg-green-500 text-sm">Als erledigt markieren</button>
                            </div>
                        </div>
                    `;
                }
                adminContentArea.innerHTML = `<div class="space-y-4">${reportsHtml}</div>`;
                adminContentArea.querySelectorAll('.resolve-report-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        showConfirmationModal('M√∂chtest du diese Meldung wirklich als erledigt markieren?', async () => {
                            await updateDoc(doc(db, 'reports', btn.dataset.reportId), { status: 'resolved' });
                            showToast('Meldung als erledigt markiert.', 'success');
                            renderAdminReports();
                        });
                    });
                });

            } catch (error) {
                console.error("Error fetching reports:", error);
                adminContentArea.innerHTML = `<div class="text-center p-4"><p class="text-red-400">Fehler beim Laden der Meldungen.</p><p class="text-gray-400 mt-2 text-sm">Dies liegt wahrscheinlich an den Firestore-Sicherheitsregeln. Administratoren ben√∂tigen eine "list"-Berechtigung f√ºr die "reports"-Sammlung, um alle Meldungen anzuzeigen.</p></div>`;
            }
        };
        
        const showAdminPanel = async () => {
            document.getElementById('user-dropdown-logged-in')?.classList.add('hidden');

            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Admin Panel';
            document.getElementById('generic-modal-subtitle').textContent = '';
            
            let tabs = `<button data-tab="users" class="admin-tab-btn py-2 px-3 text-white border-b-2 border-blue-500 font-semibold text-sm">Benutzer</button>
                        <button data-tab="reports" class="admin-tab-btn py-2 px-3 text-gray-400 border-b-2 border-transparent hover:border-gray-500 text-sm">Meldungen</button>`;
            if (currentUserProfile.role === 'founder') {
                tabs += `<button data-tab="settings" class="admin-tab-btn py-2 px-3 text-gray-400 border-b-2 border-transparent hover:border-gray-500 text-sm">Seiteneinstellungen</button>`;
            }

            document.getElementById('generic-modal-header-actions').innerHTML = `
                <div class="border-b border-slate-700">
                    <nav class="flex space-x-1">${tabs}</nav>
                </div>
            `;
            modalContent.innerHTML = '<div id="admin-content-area" class="mt-4"><div class="loader"></div></div>';
            modalFooter.innerHTML = '';
            openModal(genericModal);
            
            document.querySelectorAll('.admin-tab-btn').forEach(btn => {
                btn.onclick = (e) => {
                    document.querySelectorAll('.admin-tab-btn').forEach(b => { b.classList.remove('text-white', 'border-blue-500'); b.classList.add('text-gray-400', 'border-transparent'); });
                    e.currentTarget.classList.add('text-white', 'border-blue-500');
                    e.currentTarget.classList.remove('text-gray-400', 'border-transparent');
                    const tab = e.currentTarget.dataset.tab;
                    if (tab === 'users') renderAdminUsers();
                    else if (tab === 'reports') renderAdminReports();
                    else if (tab === 'settings') renderSiteSettings();
                };
            });

            renderAdminUsers();
        };

        const toggleAdminRole = async (userId, currentRole) => {
            if (currentUserProfile.role !== 'founder') { showToast('Nur der Gr√ºnder kann Rollen √§ndern.', 'error'); return; }
            const newRole = currentRole === 'admin' ? 'user' : 'admin';
            const updateData = { role: newRole };
            if (newRole === 'admin') {
                updateData.promotedToAdminAt = serverTimestamp();
            } else {
                updateData.promotedToAdminAt = deleteField();
            }
            
            showLoader('Rolle wird aktualisiert...');
            try {
                const userRef = doc(db, `users/${userId}`);
                await updateDoc(userRef, updateData);
                showToast('Benutzerrolle aktualisiert.', 'success');
                renderAdminUsers();
            } catch (error) {
                showToast(`Fehler: ${error.message}`, 'error');
            } finally {
                hideLoader();
            }
        };

        const toggleBanStatus = async (userId, isCurrentlyBanned) => {
            const userToModifyRef = doc(db, "users", userId);
            const userToModifySnap = await getDoc(userToModifyRef);
            if (userToModifySnap.exists() && userToModifySnap.data().role === 'founder') {
                showToast("Der Gr√ºnder kann nicht gesperrt werden.", "error");
                return;
            }

            if (isCurrentlyBanned) {
                showLoader('Benutzer wird entsperrt...');
                try {
                    await updateDoc(userToModifyRef, { banned: false, bannedBy: null });
                    showToast('Benutzer wurde entsperrt.', 'success');
                    renderAdminUsers();
                } catch (error) { showToast(`Fehler: ${error.message}`, 'error'); } finally { hideLoader(); }
            } else {
                showLoader('Benutzer wird gesperrt...');
                try {
                    await updateDoc(userToModifyRef, { 
                        banned: true,
                        bannedBy: currentUser.uid,
                        banCount: increment(1)
                    });
                    showToast('Benutzer wurde gesperrt.', 'success');
                    renderAdminUsers();
                } catch (error) { showToast(`Fehler: ${error.message}`, 'error'); } finally { hideLoader(); }
            }
        };

        // --- AUTHENTICATION LOGIC ---
        const handleLogout = async () => {
            if (!currentUser) return;
            showLoader('Abmelden...');

            const uid = currentUser.uid;

            // 1. Detach all live listeners immediately.
            if (unsubscribeUserListener) {
                unsubscribeUserListener();
                unsubscribeUserListener = null;
            }
            if (unsubscribeChatListener) unsubscribeChatListener();
            if (unsubscribeTypingListener) unsubscribeTypingListener();
            if (unsubscribeFriendStatusListener) unsubscribeFriendStatusListener();
            Object.values(friendsStatusUnsubscribers).forEach(unsub => unsub());
            friendsStatusUnsubscribers = {};

            try {
                // 2. Update presence in the background (fire-and-forget).
                const userStatusFirestoreRef = doc(db, 'users', uid);
                updateDoc(userStatusFirestoreRef, { presence: 'offline', last_seen: serverTimestamp() });
                const userStatusDatabaseRef = dbRef(rtdb, '/status/' + uid);
                onDisconnect(userStatusDatabaseRef).cancel();
                set(userStatusDatabaseRef, { state: 'offline', last_changed: rtdbServerTimestamp() });

                // 3. Sign out from Firebase Auth.
                await signOut(auth);
                
                // 4. Show success message.
                showToast('Erfolgreich abgemeldet.', 'info');

            } catch (error) {
                console.error("Logout Error:", error);
                showToast(`Fehler beim Abmelden: ${error.message}`, 'error');
            } finally {
                // 5. Force UI reset and state cleanup, regardless of success or failure.
                currentUser = null;
                currentUserProfile = null;
                updateUIForLoggedOutUser();
                hideLoader();
            }
        };


        const setupPresenceSystem = (user) => {
            const uid = user.uid;
            const userStatusDatabaseRef = dbRef(rtdb, '/status/' + uid);
            const userStatusFirestoreRef = doc(db, '/users/' + uid);

            const isOfflineForDatabase = { state: 'offline', last_changed: rtdbServerTimestamp() };
            const isOnlineForDatabase = { state: 'online', last_changed: rtdbServerTimestamp() };
            const isAwayForDatabase = { state: 'away', last_changed: rtdbServerTimestamp() };

            const isOfflineForFirestore = { presence: 'offline', last_seen: serverTimestamp() };
            const isOnlineForFirestore = { presence: 'online' };
            const isAwayForFirestore = { presence: 'away' };

            const connectedRef = dbRef(rtdb, '.info/connected');
            onValue(connectedRef, (snapshot) => {
                if (snapshot.val() === false) {
                    // Firestore's onDisconnect will handle this.
                    return;
                }

                onDisconnect(userStatusDatabaseRef).set(isOfflineForDatabase).then(() => {
                    onDisconnect(userStatusFirestoreRef).update(isOfflineForFirestore);
                    set(userStatusDatabaseRef, isOnlineForDatabase);
                    updateDoc(userStatusFirestoreRef, isOnlineForFirestore);
                });
            });
            
            const resetInactivityTimer = () => {
                if (inactivityTimer) clearTimeout(inactivityTimer);

                getDoc(userStatusFirestoreRef).then(docSnap => {
                    if (docSnap.exists() && docSnap.data().presence !== 'online') {
                        set(userStatusDatabaseRef, isOnlineForDatabase);
                        updateDoc(userStatusFirestoreRef, isOnlineForFirestore);
                    }
                });
                
                inactivityTimer = setTimeout(() => {
                    set(userStatusDatabaseRef, isAwayForDatabase);
                    updateDoc(userStatusFirestoreRef, isAwayForFirestore);
                }, 150000); // 2.5 minutes
            };

            window.addEventListener('mousemove', resetInactivityTimer, { passive: true });
            window.addEventListener('mousedown', resetInactivityTimer, { passive: true });
            window.addEventListener('keypress', resetInactivityTimer, { passive: true });
            window.addEventListener('scroll', resetInactivityTimer, { passive: true });
            window.addEventListener('touchstart', resetInactivityTimer, { passive: true });
            
            resetInactivityTimer();
        };

        onAuthStateChanged(auth, async (user) => {
            if (isRegistering) { return; }

            let metadata = { maintenanceEnabled: false, founderId: null };
            try {
                const metadataRef = doc(db, `app-metadata/${appId}`);
                const metadataSnap = await getDoc(metadataRef);
                if (metadataSnap.exists()) {
                    metadata = metadataSnap.data();
                }
            } catch (error) {
                console.warn("Could not fetch app metadata. Assuming no maintenance.", error);
            }
            
            const isFounder = user && user.uid === metadata.founderId;

            if (metadata.maintenanceEnabled && !isFounder) {
                renderMaintenanceScreen();
                hideLoader();
                return;
            }

            appContainer.classList.remove('hidden');
            appContainer.classList.add('flex');
            maintenanceScreen.classList.add('hidden');
            maintenanceScreen.classList.remove('flex');

            if (user) {
                currentUser = user; 
                if (unsubscribeUserListener) unsubscribeUserListener();
                const userDocRef = doc(db, `users/${user.uid}`);
                
                setupPresenceSystem(user);

                unsubscribeUserListener = onSnapshot(userDocRef, async (docSnap) => {
                    if (docSnap.exists()) {
                        currentUserProfile = { id: docSnap.id, ...docSnap.data() };
                        
                        const unreadChats = currentUserProfile.unreadChats || [];
                        const badge = document.getElementById('chat-notification-badge');
                        if (badge) {
                            if (unreadChats.length > 0) {
                                badge.classList.remove('hidden');
                                if (unreadChats.length > previousUnreadCount) {
                                    showNotificationSound();
                                }
                            } else {
                                badge.classList.add('hidden');
                            }
                        }
                        previousUnreadCount = unreadChats.length;

                        if (currentUserProfile.banned) {
                            await renderBannedScreen();
                        } else if (!user.emailVerified && !currentUserProfile.isManuallyVerified) {
                            renderVerificationScreen();
                        } else {
                            updateUIForLoggedInUser();
                            const welcomeBackShown = localStorage.getItem('welcomeBackShown_v2');
                            if (!welcomeBackShown) {
                                showToast('Wir sind wieder Zur√ºck ü•≥', 'success');
                                localStorage.setItem('welcomeBackShown_v2', 'true');
                            }
                        }
                    } else {
                        if (currentUserProfile) {
                            console.error("User document was deleted. Logging out.");
                            handleLogout();
                        }
                    }
                    hideLoader();
                }, (error) => {
                    console.error("Error with user listener:", error);
                    showToast("Verbindung zum Benutzerprofil verloren.", "error");
                    handleLogout();
                    hideLoader();
                });
            } else {
                currentUser = null;
                currentUserProfile = null; 
                if (unsubscribeUserListener) {
                    unsubscribeUserListener();
                    unsubscribeUserListener = null;
                }
                updateUIForLoggedOutUser();
                hideLoader();
            }
        });


        const updateUIForLoggedInUser = () => {
            const crownIcon = currentUserProfile.role === 'founder' || currentUserProfile.role === 'admin' ? `<i data-lucide="crown" class="w-5 h-5 text-yellow-400"></i>` : '';
            headerTitle.innerHTML = `<span class="flex items-center gap-2">Willkommen, ${currentUserProfile.displayName} ${crownIcon}</span>`;
            headerActions.innerHTML = `
                <button id="chat-button" class="relative text-gray-300 hover:text-white">
                    <i data-lucide="message-square"></i>
                    <span id="chat-notification-badge" class="hidden absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full border-2 border-slate-800"></span>
                </button>
                <div class="relative">
                    <button id="profile-button-logged-in" class="w-10 h-10 rounded-full bg-slate-700 flex items-center justify-center hover:bg-slate-600">
                        <img src="${currentUserProfile.photoURL || `https://placehold.co/40x40/1E293B/FFFFFF?text=${currentUserProfile.displayName.charAt(0)}`}" class="w-10 h-10 rounded-full object-cover">
                    </button>
                    <div id="user-dropdown-logged-in" class="hidden absolute right-0 mt-2 w-56 glass-card shadow-lg z-[51] p-2 rounded-xl">
                        <a href="#" id="settings-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="settings" class="w-4 h-4"></i> Einstellungen</a>
                        <a href="#" id="upload-video-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="video" class="w-4 h-4"></i> Video hochladen</a>
                        <a href="#" id="change-pic-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="camera" class="w-4 h-4"></i> Profilbild √§ndern</a>
                        <a href="#" id="notes-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="notebook" class="w-4 h-4"></i> Meine Notizen</a>
                        ${currentUserProfile.role !== 'user' ? `<a href="#" id="admin-panel-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="shield" class="w-4 h-4"></i> Admin Panel</a>` : ''}
                        <div class="border-t border-slate-700 my-1"></div>
                        <a href="#" id="logout-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-red-400 hover:bg-red-500 hover:text-white rounded-md"><i data-lucide="log-out" class="w-4 h-4"></i> Abmelden</a>
                    </div>
                </div>`;
            document.getElementById('profile-button-logged-in').addEventListener('click', () => document.getElementById('user-dropdown-logged-in').classList.toggle('hidden'));
            document.getElementById('chat-button').addEventListener('click', openChatsAndFriendsModal);
            document.getElementById('logout-btn').addEventListener('click', handleLogout);
            document.getElementById('settings-btn').addEventListener('click', showSettingsModal);
            document.getElementById('upload-video-btn').addEventListener('click', showUploadVideoModal);
            document.getElementById('change-pic-btn').addEventListener('click', showProfilePicModal);
            document.getElementById('notes-btn').addEventListener('click', showNotesModal);
            if (document.getElementById('admin-panel-btn')) {
                document.getElementById('admin-panel-btn').addEventListener('click', showAdminPanel);
            }
            lucide.createIcons();
            renderVideoFeedView();
        };

        const updateUIForLoggedOutUser = () => {
            headerTitle.textContent = 'Fortnite Status';
            headerActions.innerHTML = `<button id="profile-button-logged-out" class="w-10 h-10 rounded-full bg-slate-700 flex items-center justify-center hover:bg-slate-600"><i data-lucide="user" class="w-6 h-6 text-gray-400"></i></button>`;
            document.getElementById('profile-button-logged-out').addEventListener('click', () => showAuthModal('login'));
            lucide.createIcons();
            renderLoggedOutView();
        };
        
        const renderLoggedOutView = () => {
            mainContent.innerHTML = `
            <div class="w-full max-w-2xl space-y-6 mx-auto">
                <div class="glass-card p-6 flex justify-between items-center">
                    <div>
                        <h2 class="text-xl font-bold">Epic Games-Dienststatus</h2>
                        <p class="text-gray-400">All Systems Operational</p>
                    </div>
                    <div class="flex items-center gap-2 text-green-400">
                        <i data-lucide="check-circle-2"></i>
                        <span>Alle Systeme operationell</span>
                    </div>
                </div>
                <div class="glass-card p-6">
                    <h2 class="text-xl font-bold">Willkommen!</h2>
                    <p class="text-gray-400 mt-2">Dies ist deine zentrale Anlaufstelle f√ºr den Fortnite-Status. Melde dich an, um Videos anzusehen und die Chat-Funktionen zu nutzen!</p>
                </div>
            </div>`;
            lucide.createIcons();
        };

        const renderVerificationScreen = () => {
            headerTitle.textContent = 'E-Mail Best√§tigung';
            headerActions.innerHTML = `<button id="logout-btn" class="btn-secondary">Abmelden</button>`;
            document.getElementById('logout-btn').addEventListener('click', handleLogout);

            mainContent.innerHTML = `
            <div class="w-full max-w-2xl space-y-6 mx-auto text-center">
                <div class="glass-card p-8">
                    <i data-lucide="mail-check" class="w-16 h-16 mx-auto text-blue-400 mb-4"></i>
                    <h2 class="text-2xl font-bold">Best√§tige deine E-Mail-Adresse</h2>
                    <p class="text-gray-400 mt-2 mb-6">Wir haben eine Best√§tigungs-E-Mail an <strong>${auth.currentUser.email}</strong> gesendet. Bitte klicke auf den Link in der E-Mail, um dein Konto zu aktivieren. √úberpr√ºfe auch deinen Spam-Ordner.</p>
                    <div class="flex flex-col sm:flex-row gap-4 justify-center">
                        <button id="resend-verification-btn" class="btn-primary">E-Mail erneut senden</button>
                        <button id="check-verification-btn" class="btn-secondary">Ich habe verifiziert, weiter</button>
                    </div>
                </div>
            </div>`;
            lucide.createIcons();

            document.getElementById('resend-verification-btn').addEventListener('click', async () => {
                try {
                    await sendEmailVerification(auth.currentUser);
                    showToast("Best√§tigungs-E-Mail wurde erneut gesendet.", "success");
                } catch (error) {
                    console.error("Error resending verification email:", error);
                    showToast("Fehler beim Senden der E-Mail.", "error");
                }
            });
            document.getElementById('check-verification-btn').addEventListener('click', async () => {
                await auth.currentUser.reload();
            });
        };
        
        const renderBannedScreen = async () => {
            headerTitle.textContent = 'Konto gesperrt';
            headerActions.innerHTML = `<button id="logout-btn" class="btn-secondary">Abmelden</button>`;
            document.getElementById('logout-btn').addEventListener('click', handleLogout);
            
            let bannerName = 'einem Administrator';
            if (currentUserProfile.bannedBy) {
                const bannerDoc = await getDoc(doc(db, 'users', currentUserProfile.bannedBy));
                if (bannerDoc.exists()) {
                    bannerName = bannerDoc.data().displayName;
                }
            }
            
            mainContent.innerHTML = `
            <div class="w-full max-w-2xl space-y-6 mx-auto text-center">
                <div class="glass-card p-8">
                    <i data-lucide="gavel" class="w-16 h-16 mx-auto text-red-500 mb-4"></i>
                    <h2 class="text-2xl font-bold">Dein Konto wurde gesperrt</h2>
                    <p class="text-gray-400 mt-2">Du wurdest von <strong>${bannerName}</strong> gesperrt. Du hast keinen Zugriff auf die App-Funktionen.</p>
                </div>
            </div>`;
            lucide.createIcons();
        };

        const showAuthModal = (view = 'login') => {
            const authContent = document.getElementById('auth-content');
            const authTitle = document.getElementById('auth-title');
            if (view === 'login') {
                authTitle.textContent = 'Anmelden';
                authContent.innerHTML = `
                    <form id="login-form">
                        <input type="email" id="login-email" placeholder="E-Mail" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required>
                        <input type="password" id="login-password" placeholder="Passwort" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required>
                        <button type="submit" class="btn-primary w-full">Anmelden</button>
                    </form>
                    <div class="text-center mt-4 text-sm">
                        <a href="#" id="show-reset" class="text-blue-400 hover:underline">Passwort vergessen?</a>
                    </div>
                    <p class="text-center mt-2 text-sm text-gray-400">
                        Noch kein Konto? <a href="#" id="show-register" class="text-blue-400 hover:underline">Registrieren</a>
                    </p>`;
                document.getElementById('show-register').addEventListener('click', (e) => { e.preventDefault(); showAuthModal('register'); });
                document.getElementById('show-reset').addEventListener('click', (e) => { e.preventDefault(); showAuthModal('reset'); });
                document.getElementById('login-form').addEventListener('submit', handleLogin);
            } else if (view === 'register') {
                authTitle.textContent = 'Registrieren';
                authContent.innerHTML = `
                    <form id="register-form">
                        <input type="text" id="register-displayname" placeholder="Anzeigename" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required>
                        <input type="email" id="register-email" placeholder="E-Mail" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required>
                        <input type="password" id="register-password" placeholder="Passwort" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-6" required>
                        <button type="submit" class="btn-primary w-full">Konto erstellen</button>
                    </form>
                    <p class="text-center mt-4 text-sm text-gray-400">Bereits ein Konto? <a href="#" id="show-login" class="text-blue-400 hover:underline">Anmelden</a></p>`;
                document.getElementById('show-login').addEventListener('click', (e) => { e.preventDefault(); showAuthModal('login'); });
                document.getElementById('register-form').addEventListener('submit', handleRegister);
            } else if (view === 'reset') {
                 authTitle.textContent = 'Passwort zur√ºcksetzen';
                authContent.innerHTML = `
                    <form id="reset-form">
                        <p class="text-gray-400 mb-4">Gib deine E-Mail-Adresse ein, um einen Link zum Zur√ºcksetzen deines Passworts zu erhalten.</p>
                        <input type="email" id="reset-email" placeholder="E-Mail" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required>
                        <button type="submit" class="btn-primary w-full">Link anfordern</button>
                    </form>
                    <p class="text-center mt-4 text-sm"><a href="#" id="back-to-login" class="text-blue-400 hover:underline">Zur√ºck zum Login</a></p>`;
                document.getElementById('back-to-login').addEventListener('click', (e) => { e.preventDefault(); showAuthModal('login'); });
                document.getElementById('reset-form').addEventListener('submit', handlePasswordReset);
            }
            openModal(authModal);
        };

        const handleLogin = async (e) => {
            e.preventDefault();
            showLoader('Anmelden...');
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            try {
                await signInWithEmailAndPassword(auth, email, password);
                closeModal(authModal);
            } catch (error) {
                if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-credential') {
                    showToast('F√ºr diese E-Mail-Adresse wurde kein Konto gefunden.', 'error');
                } else if (error.code === 'auth/wrong-password') {
                    showToast('Falsches Passwort. Bitte versuche es erneut.', 'error');
                } else {
                    showToast(`Fehler bei der Anmeldung: ${error.message}`, 'error');
                }
                hideLoader();
            }
        };
        const handleRegister = async (e) => {
            e.preventDefault();
            showLoader('Konto wird erstellt...');
            const displayName = document.getElementById('register-displayname').value;
            const email = document.getElementById('register-email').value;
            const password = document.getElementById('register-password').value;
            if (displayName.length < 3) { showToast('Anzeigename muss mindestens 3 Zeichen lang sein.', 'error'); hideLoader(); return; }
            
            isRegistering = true;
            let tempUser = null; 

            try {
                const metadataRef = doc(db, `app-metadata/${appId}`);
                const metadataSnap = await getDoc(metadataRef);
                let role = 'user';
                let isFounder = false;
                if (!metadataSnap.exists() || !metadataSnap.data().founderId) {
                    role = 'founder';
                    isFounder = true;
                }
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                tempUser = userCredential.user; 

                await updateProfile(tempUser, { displayName });
                const userDocRef = doc(db, `users/${tempUser.uid}`);
                await setDoc(userDocRef, { 
                    uid: tempUser.uid, 
                    displayName, 
                    email, 
                    role, 
                    createdAt: serverTimestamp(), 
                    photoURL: '', 
                    friends: [], 
                    banned: false, 
                    banCount: 0, 
                    bannedBy: null,
                    unreadChats: [],
                    isManuallyVerified: false,
                    notificationsEnabled: true, // Default sound notifications
                    browserNotificationsEnabled: true // Default browser notifications
                });
                
                if (isFounder) {
                    await setDoc(metadataRef, { founderId: tempUser.uid, maintenanceEnabled: false, maintenanceWhitelist: [] });
                }
                
                await sendEmailVerification(tempUser);
                showToast('Registrierung erfolgreich! Bitte √ºberpr√ºfe dein Postfach (auch Spam) zur Verifizierung.', 'success');
                closeModal(authModal);
            } catch (error) {
                if (tempUser) {
                    await deleteUser(tempUser).catch(delErr => console.error("Failed to delete temporary user:", delErr));
                }
                if (error.code === 'auth/email-already-in-use') {
                    showToast('Diese E-Mail-Adresse wird bereits verwendet.', 'error');
                } else {
                    console.error("Registration error:", error);
                    showToast(`Fehler bei der Registrierung: ${error.message}`, 'error');
                }
            } finally {
                isRegistering = false;
                if (auth.currentUser && auth.currentUser.uid === tempUser?.uid && !auth.currentUser.emailVerified) {
                    await signOut(auth);
                }
                hideLoader();
            }
        };

        const handlePasswordReset = async (e) => {
            e.preventDefault();
            const email = document.getElementById('reset-email').value;
            if (!email) {
                showToast("Bitte gib eine E-Mail-Adresse ein.", "error");
                return;
            }
            showLoader("Sende E-Mail...");
            try {
                await sendPasswordResetEmail(auth, email);
                showToast("E-Mail zum Zur√ºcksetzen des Passworts wurde gesendet. Bitte √ºberpr√ºfe dein Postfach.", "success");
                showAuthModal('login');
            } catch (error) {
                console.error("Password reset error:", error);
                showToast("Fehler beim Senden der E-Mail.", "error");
            } finally {
                hideLoader();
            }
        };

        // --- VIDEO FEED & PLAYER ---
        const renderVideoFeedView = () => {
            mainContent.innerHTML = `
                <div class="w-full max-w-7xl mx-auto">
                    <div class="glass-card p-4 mb-6 flex justify-between items-center max-w-2xl mx-auto">
                        <h2 class="text-lg font-bold">Epic Games-Dienststatus</h2>
                        <div class="flex items-center gap-2 text-green-400">
                            <i data-lucide="check-circle-2"></i>
                            <span>Alle Systeme operationell</span>
                        </div>
                    </div>
                    <div id="video-grid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"></div>
                </div>`;
            lucide.createIcons();
            
            const videosQuery = query(collection(db, "videos"));
            onSnapshot(videosQuery, (snapshot) => {
                const videoGrid = document.getElementById('video-grid');
                if (!videoGrid) return;
                videoGrid.innerHTML = '';
                if (snapshot.empty) { 
                    videoGrid.innerHTML = `<p class="col-span-full text-center text-gray-400">Noch keine Videos vorhanden. Lade das erste hoch!</p>`; 
                    return;
                }
                
                const videos = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                videos.sort((a, b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0));

                videos.forEach(video => {
                    const card = document.createElement('div');
                    card.className = 'glass-card rounded-lg overflow-hidden group';
                    
                    const canDelete = currentUserProfile && (currentUserProfile.role === 'admin' || currentUserProfile.role === 'founder' || video.uploaderId === currentUser.uid);

                    card.innerHTML = `
                        <div class="relative">
                            <img src="${video.thumbnailUrl}" alt="${video.title}" class="w-full h-48 object-cover transition-transform duration-300 group-hover:scale-105 cursor-pointer">
                            <div class="absolute bottom-2 right-2 bg-black/50 text-white text-xs px-2 py-1 rounded-md flex items-center gap-1">
                                <i data-lucide="eye" class="w-4 h-4"></i>
                                <span>${video.views || 0}</span>
                            </div>
                            ${canDelete ? `<button data-video-id="${video.id}" class="delete-video-btn absolute top-2 right-2 bg-red-600/70 hover:bg-red-500 p-2 rounded-full opacity-0 group-hover:opacity-100 transition-opacity"><i data-lucide="trash-2" class="w-4 h-4"></i></button>` : ''}
                        </div>
                        <div class="p-4">
                            <h3 class="font-bold text-white truncate">${video.title}</h3>
                            <p class="text-sm text-gray-400">${video.uploaderName}</p>
                        </div>`;
                    card.querySelector('img').addEventListener('click', () => openVideoPlayer(video.id));
                    if(canDelete) {
                        card.querySelector('.delete-video-btn').addEventListener('click', (e) => {
                            e.stopPropagation();
                            showConfirmationModal(`M√∂chtest du das Video "${video.title}" wirklich l√∂schen?`, () => deleteVideo(video.id));
                        });
                    }
                    videoGrid.appendChild(card);
                });
                lucide.createIcons();
            });
        };

        const openVideoPlayer = async (videoId) => {
            const videoRef = doc(db, "videos", videoId);
            await updateDoc(videoRef, { views: increment(1) });
            const videoSnap = await getDoc(videoRef);
            if (!videoSnap.exists()) { showToast("Video nicht gefunden.", "error"); return; }
            const video = { id: videoSnap.id, ...videoSnap.data() };
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            const modalHeaderActions = document.getElementById('generic-modal-header-actions');
            modalTitle.textContent = video.title;
            document.getElementById('generic-modal-subtitle').textContent = '';
            modalHeaderActions.innerHTML = '';
            modalContent.innerHTML = `
                <video controls autoplay class="w-full rounded-lg bg-black max-h-[60vh]"><source src="${video.videoUrl}" type="video/mp4"></video>
                <div class="mt-4 flex justify-between items-center">
                    <p class="text-gray-400">Hochgeladen von ${video.uploaderName}</p>
                    <div class="flex items-center gap-4">
                        <button id="like-video-btn" class="flex items-center gap-2 btn-secondary"><i data-lucide="heart"></i><span id="like-count">${video.likes?.length || 0}</span></button>
                        <button id="report-video-btn" class="flex items-center gap-2 btn-secondary bg-yellow-600/50 hover:bg-yellow-500/50 text-yellow-300"><i data-lucide="flag"></i><span>Melden</span></button>
                    </div>
                </div>
                <div class="mt-4 border-t border-slate-700 pt-4"><h4 class="font-semibold mb-2 text-lg">Kommentare</h4><div id="video-comments" class="space-y-3 max-h-40 overflow-y-auto"></div></div>`;
            modalFooter.innerHTML = `<form id="add-comment-form" class="flex gap-2"><input id="comment-input" class="flex-grow p-2 bg-slate-800 border border-slate-700 rounded-lg" placeholder="Kommentar hinzuf√ºgen..." autocomplete="off"><button type="submit" class="btn-primary">Senden</button></form>`;
            openModal(genericModal);
            updateLikeButton(videoId);
            renderComments(videoId);
            document.getElementById('like-video-btn').addEventListener('click', () => toggleLike(videoId));
            document.getElementById('report-video-btn').addEventListener('click', () => showReportModal(videoId, 'video'));
            document.getElementById('add-comment-form').addEventListener('submit', (e) => { e.preventDefault(); const input = document.getElementById('comment-input'); addComment(videoId, input.value); input.value = ''; });
            lucide.createIcons();
        };

        const deleteVideo = async (videoId) => {
            showLoader("L√∂sche Video...");
            try {
                const videoRef = doc(db, "videos", videoId);
                const videoSnap = await getDoc(videoRef);
                if (!videoSnap.exists()) {
                    throw new Error("Video document not found.");
                }
                const videoData = videoSnap.data();

                const videoFileRef = storageRef(storage, videoData.videoUrl);
                const thumbFileRef = storageRef(storage, videoData.thumbnailUrl);
                await deleteObject(videoFileRef);
                await deleteObject(thumbFileRef);

                const commentsQuery = query(collection(db, `videos/${videoId}/comments`));
                const commentsSnapshot = await getDocs(commentsQuery);
                const batch = writeBatch(db);
                commentsSnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();

                await deleteDoc(videoRef);

                showToast("Video erfolgreich gel√∂scht.", "success");
                closeModal(genericModal);
            } catch (error) {
                console.error("Error deleting video:", error);
                showToast("Fehler beim L√∂schen des Videos.", "error");
            } finally {
                hideLoader();
            }
        };

        const updateLikeButton = async (videoId) => {
            const likeBtn = document.getElementById('like-video-btn');
            if(!likeBtn) return;
            const likeIcon = likeBtn.querySelector('i');
            const likeCount = document.getElementById('like-count');
            if (!currentUser) return;
            const videoRef = doc(db, "videos", videoId);
            const videoSnap = await getDoc(videoRef);
            if (videoSnap.exists()) {
                const likes = videoSnap.data().likes || [];
                likeCount.textContent = likes.length;
                if (likes.includes(currentUser.uid)) { likeIcon.classList.add('fill-current', 'text-red-500'); } else { likeIcon.classList.remove('fill-current', 'text-red-500'); }
            }
        };

        const toggleLike = async (videoId) => {
            if (!currentUser) { showToast("Bitte anmelden, um zu liken.", "info"); return; }
            const videoRef = doc(db, "videos", videoId);
            const videoSnap = await getDoc(videoRef);
            if(videoSnap.exists()){
                const likes = videoSnap.data().likes || [];
                if(likes.includes(currentUser.uid)){ await updateDoc(videoRef, { likes: arrayRemove(currentUser.uid) }); } else { await updateDoc(videoRef, { likes: arrayUnion(currentUser.uid) }); }
                updateLikeButton(videoId);
            }
        };

        const renderComments = (videoId) => {
            const container = document.getElementById('video-comments');
            if(!container) return;
            const q = query(collection(db, `videos/${videoId}/comments`), orderBy('createdAt', 'asc'));
            onSnapshot(q, (snapshot) => {
                container.innerHTML = '';
                if(snapshot.empty){ container.innerHTML = '<p class="text-gray-500">Noch keine Kommentare.</p>'; return; }
                snapshot.forEach(doc => {
                    const comment = doc.data();
                    const commentEl = document.createElement('div');
                    commentEl.className = 'text-sm bg-slate-800/50 p-3 rounded-lg';
                    commentEl.innerHTML = `<p><span class="font-bold text-blue-300">${comment.authorName}:</span> ${comment.text}</p>`;
                    container.appendChild(commentEl);
                });
            });
        };

        const addComment = async (videoId, text) => {
            if (!text.trim()) return;
            await addDoc(collection(db, `videos/${videoId}/comments`), { text, authorId: currentUser.uid, authorName: currentUserProfile.displayName, createdAt: serverTimestamp() });
        };

        const showUploadVideoModal = () => {
            document.getElementById('user-dropdown-logged-in')?.classList.add('hidden');
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Video hochladen';
            document.getElementById('generic-modal-subtitle').textContent = '';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `
                <div class="space-y-4">
                    <div><label class="block text-sm font-medium text-gray-300 mb-1">Video-Titel</label><input type="text" id="video-title-input" placeholder="Mein cooler Clip" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg" required></div>
                    <div><label class="block text-sm font-medium text-gray-300 mb-1">Vorschaubild</label><input type="file" id="thumbnail-upload-input" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-500" accept="image/*" required></div>
                    <div><label class="block text-sm font-medium text-gray-300 mb-1">Videodatei</label><input type="file" id="video-upload-input" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-500" accept="video/mp4,video/quicktime" required></div>
                </div>`;
            modalFooter.innerHTML = `<button id="submit-video-upload" class="btn-primary w-full">Hochladen</button>`;
            openModal(genericModal);
            document.getElementById('submit-video-upload').addEventListener('click', async () => {
                if (!currentUser) {
                    showToast("Sie m√ºssen angemeldet sein, um ein Video hochzuladen.", "error");
                    return;
                }
                const title = document.getElementById('video-title-input').value;
                const thumbnailFile = document.getElementById('thumbnail-upload-input').files[0];
                const videoFile = document.getElementById('video-upload-input').files[0];
                if (!title || !thumbnailFile || !videoFile) { showToast("Bitte alle Felder ausf√ºllen.", "error"); return; }
                
                modalContent.innerHTML = `
                    <div id="upload-progress-container">
                        <p id="upload-status-text" class="text-center mb-2">Lade Vorschaubild hoch...</p>
                        <div class="w-full bg-slate-700 rounded-full h-4"><div id="progress-bar" class="bg-blue-600 h-4 rounded-full transition-all duration-300" style="width: 0%"></div></div>
                        <p id="progress-percentage" class="text-center text-sm mt-1">0%</p>
                        <p id="time-remaining" class="text-center text-xs text-gray-400 mt-1"></p>
                    </div>`;
                modalFooter.innerHTML = '';

                const uploadFile = (file, storagePath, statusText) => {
                    return new Promise((resolve, reject) => {
                        const fileRef = storageRef(storage, storagePath);
                        const metadata = { contentType: file.type };
                        const uploadTask = uploadBytesResumable(fileRef, file, metadata);
                        const uploadStartTime = Date.now();
                        const statusEl = document.getElementById('upload-status-text');
                        if (statusEl) statusEl.textContent = statusText;

                        uploadTask.on('state_changed', 
                            (snapshot) => {
                                const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                                const progressBar = document.getElementById('progress-bar');
                                const progressPercentage = document.getElementById('progress-percentage');
                                const timeRemainingEl = document.getElementById('time-remaining');

                                if(progressBar) progressBar.style.width = progress + '%';
                                if(progressPercentage) progressPercentage.textContent = Math.round(progress) + '%';
                                
                                const elapsedTime = (Date.now() - uploadStartTime) / 1000;
                                if (elapsedTime > 0.5 && snapshot.bytesTransferred > 0) {
                                    const uploadSpeed = snapshot.bytesTransferred / elapsedTime;
                                    const bytesRemaining = snapshot.totalBytes - snapshot.bytesTransferred;
                                    const secondsRemaining = Math.round(bytesRemaining / uploadSpeed);
                                    if (timeRemainingEl && isFinite(secondsRemaining) && secondsRemaining > 0) {
                                        timeRemainingEl.textContent = `Verbleibende Zeit: ca. ${secondsRemaining} Sekunden`;
                                    } else if(timeRemainingEl) {
                                        timeRemainingEl.textContent = 'Berechne...';
                                    }
                                }
                            }, 
                            (error) => { 
                                console.error("Upload failed:", error);
                                const progressContainer = document.getElementById('upload-progress-container');
                                if (progressContainer) {
                                    let errorMessage = "Fehler beim Hochladen.";
                                    switch (error.code) {
                                        case 'storage/unauthorized':
                                            errorMessage = "Berechtigungsfehler. Stelle sicher, dass du angemeldet bist und die Firebase Storage Regeln den Upload erlauben.";
                                            break;
                                        case 'storage/canceled':
                                            errorMessage = "Upload abgebrochen.";
                                            break;
                                        default:
                                            errorMessage = `Ein unbekannter Fehler ist aufgetreten: ${error.code}`;
                                    }
                                    progressContainer.innerHTML = `<p class="text-red-400 text-center p-4">${errorMessage}</p>`;
                                }
                                reject(error);
                            }, 
                            async () => {
                                const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                                resolve(downloadURL);
                            }
                        );
                    });
                };

                try {
                    await auth.currentUser.getIdToken(true);
                    const thumbPath = `thumbnails/${Date.now()}_${thumbnailFile.name}`;
                    const thumbnailUrl = await uploadFile(thumbnailFile, thumbPath, 'Lade Vorschaubild hoch...');
                    
                    const videoPath = `videos/${Date.now()}_${videoFile.name}`;
                    const videoUrl = await uploadFile(videoFile, videoPath, 'Lade Video hoch...');
                    
                    const statusEl = document.getElementById('upload-status-text');
                    if (statusEl) statusEl.textContent = 'Verarbeite Daten...';
                    await addDoc(collection(db, "videos"), { title, thumbnailUrl, videoUrl, uploaderId: currentUser.uid, uploaderName: currentUserProfile.displayName, views: 0, likes: [], createdAt: serverTimestamp() });
                    
                    showToast("Video erfolgreich hochgeladen!", "success");
                    closeModal(genericModal);
                } catch (error) {
                    if (error.code) { 
                         console.error("Video upload process failed:", error);
                         showToast(`Fehler: ${error.message || 'Der Prozess konnte nicht abgeschlossen werden.'}`, "error");
                         closeModal(genericModal);
                    }
                }
            });
        };

        // --- CHATS & FRIENDS MODAL ---
        const openChatsAndFriendsModal = async () => {
            if (currentUser) {
                try {
                    const userRef = doc(db, 'users', currentUser.uid);
                    await updateDoc(userRef, { unreadChats: [] });
                } catch (error) {
                    console.error("Error clearing unread chats:", error);
                }
            }
            
            openModal(chatsFriendsModal);
            const chatsTab = chatsFriendsModal.querySelector('.tab-btn[data-tab="chats"]');
            const friendsTab = chatsFriendsModal.querySelector('.tab-btn[data-tab="friends"]');
            chatsTab.classList.add('text-white', 'border-blue-500');
            chatsTab.classList.remove('text-gray-400', 'border-transparent');
            friendsTab.classList.add('text-gray-400', 'border-transparent');
            friendsTab.classList.remove('text-white', 'border-blue-500');

            renderChatsTab();
            chatsFriendsModal.querySelectorAll('.tab-btn').forEach(btn => {
                btn.onclick = (e) => {
                    chatsFriendsModal.querySelectorAll('.tab-btn').forEach(b => { b.classList.remove('text-white', 'border-blue-500'); b.classList.add('text-gray-400', 'border-transparent'); });
                    e.currentTarget.classList.add('text-white', 'border-blue-500'); e.currentTarget.classList.remove('text-gray-400', 'border-transparent');
                    if (e.currentTarget.dataset.tab === 'chats') renderChatsTab(); else renderFriendsTab();
                };
            });
        };
        
        const renderChatsTab = async () => {
            const contentArea = document.getElementById('chats-friends-content');
            contentArea.innerHTML = `<div class="flex justify-end mb-4"><button id="create-group-btn" class="btn-primary text-sm">Neue Gruppe erstellen</button></div><div id="chats-list" class="space-y-2"></div>`;
            document.getElementById('create-group-btn').addEventListener('click', showCreateGroupModal);
            
            const list = document.getElementById('chats-list');
            list.innerHTML = `<div class="loader mx-auto"></div>`;

            const allChats = new Map();
            
            try {
                // Fetch groups where the current user is a member
                const memberGroupsQuery = query(collection(db, 'groups'), where('members', 'array-contains', currentUser.uid), where('isDeleted', '==', false));
                // Fetch all public groups
                const publicGroupsQuery = query(collection(db, 'groups'), where('isPublic', '==', true), where('isDeleted', '==', false));
                
                const [memberGroupsSnap, publicGroupsSnap] = await Promise.all([
                    getDocs(memberGroupsQuery),
                    getDocs(publicGroupsQuery)
                ]);

                memberGroupsSnap.forEach(doc => allChats.set(doc.id, { type: 'group', id: doc.id, ...doc.data() }));
                publicGroupsSnap.forEach(doc => {
                    if (!allChats.has(doc.id)) {
                        allChats.set(doc.id, { type: 'group', id: doc.id, ...doc.data() });
                    }
                });

            } catch (error) {
                console.error("Error fetching groups:", error);
                showToast("Gruppen konnten nicht geladen werden.", "error");
            }
            
            // Fetch direct messages
            const dmsQuery = query(collection(db, 'directMessages'), where('members', 'array-contains', currentUser.uid));
            const dmsSnap = await getDocs(dmsQuery);
            
            for (const dmDoc of dmsSnap.docs) {
                const chatData = dmDoc.data();
                const friendId = chatData.members.find(id => id !== currentUser.uid);
                if (friendId) {
                    try {
                        const friendDoc = await getDoc(doc(db, 'users', friendId));
                        if (friendDoc.exists()) {
                            allChats.set(dmDoc.id, { type: 'direct', id: dmDoc.id, friendId, name: friendDoc.data().displayName, photoURL: friendDoc.data().photoURL, ...chatData });
                        }
                    } catch (e) {
                         console.warn(`Could not fetch friend data for DM: ${dmDoc.id}`, e);
                    }
                }
            }

            if (allChats.size === 0) { list.innerHTML = `<p class="text-center text-gray-500 mt-8">Keine Chats vorhanden.</p>`; return; }
            
            list.innerHTML = '';
            allChats.forEach(chat => {
                const chatItem = document.createElement('div');
                chatItem.className = 'p-3 glass-card rounded-lg flex items-center justify-between gap-3';
                if (chat.type === 'group') {
                    const isMember = chat.members.includes(currentUser.uid);
                    const publicIcon = chat.isPublic ? `<i data-lucide="globe-2" class="w-4 h-4 text-cyan-400" title="√ñffentliche Gruppe"></i>` : '';
                    const founderEyeIcon = currentUserProfile.role === 'founder' && !isMember ? `<i data-lucide="eye" class="w-4 h-4 text-purple-400" title="Sichtbar als Gr√ºnder"></i>` : '';
                    chatItem.innerHTML = `
                        <div class="flex items-center gap-3 overflow-hidden flex-grow cursor-pointer" onclick="this.parentElement.querySelector('.join-btn, .open-btn')?.click()">
                            <div class="w-12 h-12 bg-slate-700 rounded-full flex-shrink-0 flex items-center justify-center"><i data-lucide="users"></i></div>
                            <div class="flex-grow overflow-hidden">
                                <p class="font-bold truncate flex items-center gap-2">${chat.name} ${publicIcon} ${founderEyeIcon}</p>
                                <p class="text-sm text-gray-400">${chat.members.length} Mitglieder</p>
                            </div>
                        </div>
                        ${isMember 
                            ? `<button class="open-btn btn-secondary text-sm flex-shrink-0" data-group-id="${chat.id}" data-group-name="${chat.name}">√ñffnen</button>`
                            : (chat.isPublic ? `<button class="join-btn btn-primary text-sm flex-shrink-0" data-group-id="${chat.id}">Beitreten</button>` : '')
                        }`;
                } else { // Direct Message
                    chatItem.innerHTML = `
                        <div class="flex items-center gap-3 overflow-hidden flex-grow cursor-pointer" onclick="this.parentElement.querySelector('button')?.click()">
                            <img src="${chat.photoURL || `https://placehold.co/48x48/1E293B/FFFFFF?text=${chat.name.charAt(0)}`}" class="w-12 h-12 rounded-full object-cover flex-shrink-0">
                            <div class="flex-grow overflow-hidden">
                                <p class="font-bold truncate">${chat.name}</p>
                                <p class="text-sm text-gray-400">Direktnachricht</p>
                            </div>
                        </div>
                        <button class="btn-secondary text-sm flex-shrink-0" data-friend-id="${chat.friendId}" data-friend-name="${chat.name}">√ñffnen</button>
                        `;
                }
                list.appendChild(chatItem);
            });
            list.querySelectorAll('.open-btn[data-group-id]').forEach(btn => btn.addEventListener('click', (e) => openGroupChat(e.currentTarget.dataset.groupId)));
            list.querySelectorAll('.join-btn[data-group-id]').forEach(btn => btn.addEventListener('click', async (e) => {
                const groupId = e.currentTarget.dataset.groupId;
                await updateDoc(doc(db, 'groups', groupId), { members: arrayUnion(currentUser.uid) });
                showToast("Gruppe beigetreten!", "success");
                renderChatsTab();
            }));
            list.querySelectorAll('button[data-friend-id]').forEach(btn => btn.addEventListener('click', (e) => openDirectChat(e.currentTarget.dataset.friendId, e.currentTarget.dataset.friendName)));

            lucide.createIcons();
        };

        const renderFriendsTab = () => {
            const contentArea = document.getElementById('chats-friends-content');
            contentArea.innerHTML = `
                <div class="flex justify-end mb-4"><button id="add-friend-btn" class="btn-primary text-sm">Freund hinzuf√ºgen</button></div>
                <div id="friend-requests-container" class="mb-6"><h3 class="text-lg font-semibold mb-2">Anfragen</h3><div id="friend-requests-list" class="space-y-2"></div></div>
                <div><h3 class="text-lg font-semibold mb-2">Freundesliste</h3><div id="friends-list" class="space-y-2"></div></div>`;
            document.getElementById('add-friend-btn').addEventListener('click', showAddFriendModal);
            const userDocRef = doc(db, `users/${currentUser.uid}`);
            onSnapshot(userDocRef, async (docSnap) => {
                if (docSnap.exists()) {
                    const userData = docSnap.data();
                    displayFriendRequests(userData.friendRequestsReceived || []);
                    displayFriends(userData.friends || []);
                }
            });
        };

        const showAddFriendModal = () => {
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Freund hinzuf√ºgen';
            document.getElementById('generic-modal-subtitle').textContent = 'Bitte gib die genaue Benutzer-ID deines Freundes ein.';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `
                <form id="add-friend-form">
                    <input type="text" id="add-friend-uid-input" placeholder="Benutzer-ID hier einf√ºgen..." class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg">
                </form>
            `;
            modalFooter.innerHTML = `<button id="send-friend-request-btn" class="btn-primary w-full">Anfrage senden</button>`;
            openModal(genericModal);

            document.getElementById('send-friend-request-btn').addEventListener('click', async () => {
                const targetUserId = document.getElementById('add-friend-uid-input').value.trim();
                if (!targetUserId) {
                    showToast("Bitte gib eine Benutzer-ID ein.", "error");
                    return;
                }
                if (targetUserId === currentUser.uid) {
                    showToast("Du kannst dich nicht selbst als Freund hinzuf√ºgen.", "error");
                    return;
                }
                
                showLoader("Pr√ºfe Benutzer...");
                try {
                    const userDoc = await getDoc(doc(db, 'users', targetUserId));
                    if (!userDoc.exists()) {
                        showToast("Benutzer mit dieser ID nicht gefunden.", "error");
                        hideLoader();
                        return;
                    }
                    await sendFriendRequest(targetUserId);
                    closeModal(genericModal);
                } catch (error) {
                    console.error("Error adding friend:", error);
                    showToast("Fehler beim Senden der Anfrage.", "error");
                } finally {
                    hideLoader();
                }
            });
        };

        const sendFriendRequest = async (targetUserId) => { 
            try { 
                const targetUserRef = doc(db, `users/${targetUserId}`); 
                const currentUserRef = doc(db, `users/${currentUser.uid}`); 
                const batch = writeBatch(db); 
                batch.update(targetUserRef, { friendRequestsReceived: arrayUnion(currentUser.uid) }); 
                batch.update(currentUserRef, { friendRequestsSent: arrayUnion(targetUserId) }); 
                await batch.commit(); 
                showToast('Freundschaftsanfrage gesendet!', 'success'); 
                if (currentUserProfile.friendRequestsSent) {
                    currentUserProfile.friendRequestsSent.push(targetUserId);
                } else {
                    currentUserProfile.friendRequestsSent = [targetUserId];
                }
            } catch (error) { 
                showToast(`Fehler: ${error.message}`, 'error'); 
            } 
        };
        const displayFriendRequests = async (requestUids) => {
            const container = document.getElementById('friend-requests-list'); if(!container) return;
            if (!requestUids || requestUids.length === 0) { container.innerHTML = `<p class="text-gray-500">Keine offenen Anfragen.</p>`; return; }
            container.innerHTML = '';
            for (const uid of requestUids) {
                const userDoc = await getDoc(doc(db, `users/${uid}`));
                if (userDoc.exists()) {
                    const user = userDoc.data();
                    const requestCard = document.createElement('div');
                    requestCard.className = 'glass-card p-3 flex items-center justify-between';
                    requestCard.innerHTML = `<div class="flex items-center gap-3"><img src="${user.photoURL || `https://placehold.co/40x40/1E293B/FFFFFF?text=${user.displayName.charAt(0)}`}" class="w-10 h-10 rounded-full object-cover"><p class="font-semibold text-white">${user.displayName}</p></div><div class="flex gap-2"><button data-id="${uid}" class="accept-friend-btn btn-primary text-sm">Annehmen</button><button data-id="${uid}" class="decline-friend-btn btn-secondary text-sm">Ablehnen</button></div>`;
                    container.appendChild(requestCard);
                }
            }
            container.querySelectorAll('.accept-friend-btn').forEach(btn => btn.addEventListener('click', () => acceptFriendRequest(btn.dataset.id)));
            container.querySelectorAll('.decline-friend-btn').forEach(btn => btn.addEventListener('click', () => declineFriendRequest(btn.dataset.id)));
        };
        const acceptFriendRequest = async (senderId) => { try { const batch = writeBatch(db); const currentUserRef = doc(db, `users/${currentUser.uid}`); const senderUserRef = doc(db, `users/${senderId}`); batch.update(currentUserRef, { friends: arrayUnion(senderId), friendRequestsReceived: arrayRemove(senderId) }); batch.update(senderUserRef, { friends: arrayUnion(currentUser.uid), friendRequestsSent: arrayRemove(currentUser.uid) }); await batch.commit(); showToast('Freund hinzugef√ºgt!', 'success'); } catch (error) { showToast(`Fehler: ${error.message}`, 'error'); } };
        const declineFriendRequest = async (senderId) => { try { const batch = writeBatch(db); const currentUserRef = doc(db, `users/${currentUser.uid}`); const senderUserRef = doc(db, `users/${senderId}`); batch.update(currentUserRef, { friendRequestsReceived: arrayRemove(senderId) }); batch.update(senderUserRef, { friendRequestsSent: arrayRemove(currentUser.uid) }); await batch.commit(); showToast('Anfrage abgelehnt.', 'info'); } catch (error) { showToast(`Fehler: ${error.message}`, 'error'); } };
        
        const displayFriends = async (friendUids) => {
            const container = document.getElementById('friends-list'); if(!container) return;
            
            Object.values(friendsStatusUnsubscribers).forEach(unsub => unsub());
            friendsStatusUnsubscribers = {};

            if (!friendUids || friendUids.length === 0) { container.innerHTML = `<p class="text-gray-500">Du hast noch keine Freunde.</p>`; return; }
            
            container.innerHTML = '';
            
            for (const uid of friendUids) {
                const userDocRef = doc(db, 'users', uid);
                friendsStatusUnsubscribers[uid] = onSnapshot(userDocRef, (userDoc) => {
                    if (userDoc.exists()) {
                        const user = {id: userDoc.id, ...userDoc.data()};
                        
                        let friendCard = document.getElementById(`friend-card-${user.id}`);
                        if (!friendCard) {
                            friendCard = document.createElement('div');
                            friendCard.id = `friend-card-${user.id}`;
                            friendCard.className = 'glass-card p-3 flex items-center justify-between';
                            container.appendChild(friendCard);
                        }
                        
                        let statusText = '';
                        let statusDot = '';

                        if (user.presence === 'online') {
                            statusText = `<span class="text-xs text-green-400">Online</span>`;
                            statusDot = `<div class="absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-green-500 rounded-full border-2 border-slate-800"></div>`;
                        } else if (user.presence === 'away') {
                            statusText = `<span class="text-xs text-yellow-400">Abwesend</span>`;
                            statusDot = `<div class="absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-yellow-400 rounded-full border-2 border-slate-800"></div>`;
                        } else if (user.last_seen) {
                            statusText = `<span class="text-xs text-gray-500">${formatLastSeen(user.last_seen)}</span>`;
                        }

                        friendCard.innerHTML = `
                            <div class="flex items-center gap-3 flex-grow overflow-hidden">
                                <div class="relative flex-shrink-0">
                                    <img src="${user.photoURL || `https://placehold.co/40x40/1E293B/FFFFFF?text=${user.displayName.charAt(0)}`}" class="w-10 h-10 rounded-full object-cover">
                                    ${statusDot}
                                </div>
                                <div class="overflow-hidden">
                                    <p class="font-semibold text-white truncate">${user.displayName}</p>
                                    <div id="status-text-${user.id}">${statusText}</div>
                                </div>
                            </div>
                            <div class="flex items-center gap-2 flex-shrink-0">
                                <button data-id="${user.id}" data-name="${user.displayName}" class="call-friend-btn text-green-400 hover:text-green-300"><i data-lucide="phone"></i></button>
                                <button data-id="${user.id}" data-name="${user.displayName}" class="chat-friend-btn text-blue-400 hover:text-blue-300"><i data-lucide="message-circle"></i></button>
                                <button data-id="${user.id}" data-name="${user.displayName}" class="report-user-btn text-yellow-400 hover:text-yellow-300"><i data-lucide="flag"></i></button>
                                <button data-id="${user.id}" class="remove-friend-btn text-red-500 hover:text-red-400"><i data-lucide="user-minus"></i></button>
                            </div>`;
                        
                        lucide.createIcons();
                        friendCard.querySelector('.remove-friend-btn').addEventListener('click', () => removeFriend(user.id));
                        friendCard.querySelector('.chat-friend-btn').addEventListener('click', () => openDirectChat(user.id, user.displayName));
                        friendCard.querySelector('.call-friend-btn').addEventListener('click', () => showCallingModal(user.displayName));
                        friendCard.querySelector('.report-user-btn').addEventListener('click', () => showReportModal(user.id, 'user', { userName: user.displayName }));
                    }
                });
            }
        };
        const removeFriend = async (friendId) => { showConfirmationModal('Bist du sicher, dass du diesen Freund entfernen m√∂chtest?', async () => { try { const batch = writeBatch(db); const currentUserRef = doc(db, `users/${currentUser.uid}`); const friendUserRef = doc(db, `users/${friendId}`); batch.update(currentUserRef, { friends: arrayRemove(friendId) }); batch.update(friendUserRef, { friends: arrayRemove(currentUser.uid) }); await batch.commit(); showToast('Freund entfernt.', 'info'); } catch (error) { showToast(`Fehler: ${error.message}`, 'error'); } }); };
        
        const showCreateGroupModal = () => {
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Neue Gruppe erstellen';
            document.getElementById('generic-modal-subtitle').textContent = '';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `<form id="create-group-form"><input type="text" id="group-name" placeholder="Gruppenname" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required><textarea id="group-desc" placeholder="Beschreibung" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg mb-4" required></textarea></form>`;
            modalFooter.innerHTML = `<button id="submit-create-group" class="btn-primary w-full">Erstellen</button>`;
            openModal(genericModal);
            document.getElementById('submit-create-group').addEventListener('click', async () => {
                const name = document.getElementById('group-name').value;
                const description = document.getElementById('group-desc').value;
                if (!name || !description) { showToast('Bitte f√ºlle alle Felder aus.', 'error'); return; }
                showLoader('Gruppe wird erstellt...');
                try { 
                    await addDoc(collection(db, 'groups'), { 
                        name, 
                        description, 
                        ownerId: currentUser.uid, 
                        members: [currentUser.uid], 
                        createdAt: serverTimestamp(), 
                        isPublic: false,
                        isDeleted: false 
                    }); 
                    showToast('Gruppe erfolgreich erstellt!', 'success'); 
                    closeModal(genericModal); 
                    renderChatsTab(); 
                } catch (error) { 
                    showToast(`Fehler: ${error.message}`, 'error'); 
                } finally { 
                    hideLoader(); 
                }
            });
        };

        const getChatRoomId = (uid1, uid2) => [uid1, uid2].sort().join('_');

        const openDirectChat = (friendId, friendName) => {
            const chatRoomId = getChatRoomId(currentUser.uid, friendId);
            openChat(chatRoomId, friendName, 'direct', { friendId: friendId });
        };

        const openGroupChat = async (groupId) => {
            const groupRef = doc(db, 'groups', groupId);
            const groupSnap = await getDoc(groupRef);
            if (!groupSnap.exists()) {
                showToast("Gruppe nicht gefunden.", "error");
                return;
            }
            const groupData = { id: groupSnap.id, ...groupSnap.data() };
            
            // Security Check: Ensure user is a member before opening
            if (!groupData.members.includes(currentUser.uid) && currentUserProfile.role !== 'founder') {
                 showToast("Du bist kein Mitglied dieser Gruppe.", "error");
                 return;
            }
            
            openChat(groupData.id, groupData.name, 'group', groupData);
        };

        const openChat = async (chatId, chatName, type, contextData = null) => {
            closeModal(chatsFriendsModal);

            setTimeout(async () => {
                if (currentUser) {
                    const userRef = doc(db, 'users', currentUser.uid);
                    await updateDoc(userRef, { unreadChats: arrayRemove(chatId) });
                }

                activeChatId = chatId;
                activeChatType = type;
                activeChatGroupData = type === 'group' ? contextData : null;

                if (unsubscribeChatListener) unsubscribeChatListener();
                if (unsubscribeTypingListener) unsubscribeTypingListener();
                if (unsubscribeFriendStatusListener) unsubscribeFriendStatusListener();

                const modalTitle = document.getElementById('generic-modal-title');
                const modalSubtitle = document.getElementById('generic-modal-subtitle');
                const modalContent = document.getElementById('generic-modal-content');
                const modalFooter = document.getElementById('generic-modal-footer');
                const modalHeaderActions = document.getElementById('generic-modal-header-actions');

                modalTitle.textContent = chatName;
                modalSubtitle.textContent = ''; 
                modalContent.innerHTML = `<div id="chat-messages" class="h-96 overflow-y-auto flex flex-col-reverse p-2"></div>`;
                
                modalFooter.innerHTML = `
                    <div id="typing-indicator" class="text-sm text-gray-400 h-5 italic mb-1"></div>
                    <form id="chat-form" class="flex gap-2 items-center">
                        <button type="button" id="gif-btn" class="btn-secondary p-2"><i data-lucide="file-image"></i></button>
                        <button type="button" id="mic-btn" class="btn-secondary p-2"><i data-lucide="mic"></i></button>
                        <div class="relative flex-grow">
                            <input id="chat-input" class="w-full p-2 bg-slate-800 border border-slate-700 rounded-lg pr-10" placeholder="Nachricht schreiben..." autocomplete="off">
                            <button type="button" id="emoji-btn" class="absolute right-2 top-1/2 -translate-y-1/2 text-gray-400 hover:text-white"><i data-lucide="smile"></i></button>
                        </div>
                        <button type="submit" class="btn-primary p-2"><i data-lucide="send"></i></button>
                    </form>
                `;
                
                modalHeaderActions.innerHTML = '';
                if (type === 'group' && contextData) {
                    const isOwner = contextData.ownerId === currentUser.uid;
                    const isFounder = currentUserProfile.role === 'founder';
                    const isMember = contextData.members.includes(currentUser.uid);

                    let dropdownHTML = '';
                    if (isMember) {
                         dropdownHTML += `<a href="#" id="manage-members-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="users" class="w-4 h-4"></i> ${isOwner ? 'Mitglieder verwalten' : 'Mitglieder anzeigen'}</a>`;
                         dropdownHTML += `<a href="#" id="invite-friend-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="user-plus" class="w-4 h-4"></i> Freunde einladen</a>`;
                    }

                    if (isFounder) {
                        dropdownHTML += `<a href="#" id="toggle-public-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:bg-slate-700 rounded-md"><i data-lucide="${contextData.isPublic ? 'lock' : 'globe-2'}" class="w-4 h-4"></i> ${contextData.isPublic ? 'Privat machen' : '√ñffentlich machen'}</a>`;
                    }
                    
                    dropdownHTML += `<div class="border-t border-slate-700 my-1"></div>`;

                    if (isOwner || isFounder) {
                        dropdownHTML += `<a href="#" id="delete-group-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-red-400 hover:bg-red-500 hover:text-white rounded-md"><i data-lucide="trash" class="w-4 h-4"></i> Gruppe l√∂schen</a>`;
                    }
                    if (isMember && !isOwner) {
                         dropdownHTML += `<a href="#" id="leave-group-btn" class="flex items-center gap-3 px-3 py-2 text-sm text-red-400 hover:bg-red-500 hover:text-white rounded-md"><i data-lucide="log-out" class="w-4 h-4"></i> Gruppe verlassen</a>`;
                    }

                    modalHeaderActions.innerHTML = `
                        <div class="relative">
                            <button id="group-settings-btn" class="text-gray-300 hover:text-white"><i data-lucide="settings-2"></i></button>
                            <div id="group-settings-dropdown" class="hidden absolute right-0 mt-2 w-56 glass-card shadow-lg z-[51] p-2 rounded-xl">
                                ${dropdownHTML}
                            </div>
                        </div>`;

                    document.getElementById('group-settings-btn').addEventListener('click', () => document.getElementById('group-settings-dropdown').classList.toggle('hidden'));
                    
                    const inviteBtn = document.getElementById('invite-friend-btn');
                    if (inviteBtn) inviteBtn.addEventListener('click', () => showInviteFriendsModal(chatId, contextData.members));

                    const manageBtn = document.getElementById('manage-members-btn');
                    if (manageBtn) manageBtn.addEventListener('click', () => showGroupMembersModal(chatId, contextData.ownerId));

                    const togglePublicBtn = document.getElementById('toggle-public-btn');
                    if (togglePublicBtn) togglePublicBtn.addEventListener('click', () => toggleGroupPublicStatus(chatId, contextData.isPublic));

                    const deleteBtn = document.getElementById('delete-group-btn');
                    if (deleteBtn) deleteBtn.addEventListener('click', () => deleteGroup(chatId, chatName));

                    const leaveBtn = document.getElementById('leave-group-btn');
                    if (leaveBtn) leaveBtn.addEventListener('click', () => leaveGroup(chatId, chatName));

                    const memberDetails = {};
                    for (const memberId of contextData.members) {
                        const userSnap = await getDoc(doc(db, 'users', memberId));
                        if (userSnap.exists()) {
                            memberDetails[memberId] = { id: userSnap.id, ...userSnap.data() };
                        }
                    }
                    activeChatGroupData.memberDetails = memberDetails;

                } else if (type === 'direct' && contextData.friendId) {
                    const friendRef = doc(db, 'users', contextData.friendId);
                    unsubscribeFriendStatusListener = onSnapshot(friendRef, (friendSnap) => {
                        if (friendSnap.exists()) {
                            const friendData = friendSnap.data();
                            let statusText = '';
                            if (friendData.presence === 'online') {
                                statusText = 'Online';
                            } else if (friendData.presence === 'away') {
                                statusText = 'Abwesend';
                            } else if (friendData.last_seen) {
                                statusText = `Zuletzt online: ${formatLastSeen(friendData.last_seen)}`;
                            }
                            modalSubtitle.textContent = statusText;
                        }
                    });
                }

                lucide.createIcons();
                openModal(genericModal);
                
                document.getElementById('emoji-btn').addEventListener('click', (e) => togglePicker('emoji', e.currentTarget));
                document.getElementById('gif-btn').addEventListener('click', (e) => togglePicker('gif', e.currentTarget));
                document.getElementById('mic-btn').addEventListener('click', handleRecordButtonClick);

                const collectionPath = type === 'group' ? `groups/${chatId}/messages` : `directMessages/${chatId}/messages`;
                const chatRoomRef = doc(db, type === 'group' ? 'groups' : 'directMessages', chatId);

                // Ensure the chat document exists for DMs before listening
                if (type === 'direct') {
                    try {
                        await setDoc(chatRoomRef, { members: chatId.split('_') }, { merge: true });
                    } catch (e) {
                        console.error("Error ensuring DM document exists:", e);
                        // Don't block opening the chat, sending the first message will create it.
                    }
                }

                const messagesContainer = document.getElementById('chat-messages');
                const messagesQuery = query(collection(db, collectionPath), orderBy('timestamp', 'desc'));
                unsubscribeChatListener = onSnapshot(messagesQuery, (snapshot) => {
                    snapshot.docChanges().forEach(change => {
                        if (change.type === "added") {
                            const msg = {id: change.doc.id, ...change.doc.data()};
                            
                            // Browser Notification Logic
                            if (msg.senderId !== currentUser.uid && document.hidden && currentUserProfile.browserNotificationsEnabled && Notification.permission === 'granted') {
                                showBrowserNotification(msg.senderName, msg.text || '[Bild/GIF gesendet]');
                            }

                            const messageEl = document.createElement('div');
                            const isSender = msg.senderId === currentUser.uid;
                            const isGroupOwner = type === 'group' && contextData && contextData.ownerId === currentUser.uid;
                            
                            messageEl.className = `w-full flex flex-col group relative py-2 ${isSender ? 'items-end' : 'items-start'}`;
                            
                            let readReceipt = '';
                            if (isSender && !msg.isDeleted) {
                                if (msg.readBy && msg.readBy.length > 1) {
                                    readReceipt = `<i data-lucide="check-check" class="w-4 h-4 text-blue-400"></i>`;
                                } else {
                                    readReceipt = `<i data-lucide="check" class="w-4 h-4 text-gray-500"></i>`;
                                }
                            }

                            const canDelete = (isSender || isGroupOwner) && !msg.isDeleted;
                            
                            let messageContentHTML = '';
                            if (msg.isDeleted) {
                                messageContentHTML = `<p class="text-gray-500 italic">Diese Nachricht wurde gel√∂scht.</p>`;
                            } else if (msg.type === 'gif' || msg.type === 'image') {
                                messageContentHTML = `<a href="${msg.content}" target="_blank" rel="noopener noreferrer"><img src="${msg.content}" alt="Gesendetes Bild" class="rounded-lg max-w-xs h-auto mt-1 cursor-pointer hover:opacity-80"></a>`;
                            } else if (msg.type === 'audio') {
                                messageContentHTML = `<audio controls src="${msg.content}" class="max-w-full"></audio>`;
                            } else { 
                                const linkedText = linkify(msg.text || '');
                                messageContentHTML = `<p class="text-white break-words">${linkedText}</p>`;
                            }

                            let reactionsHTML = '';
                            if (msg.reactions && Object.keys(msg.reactions).length > 0) {
                                let hasReactions = false;
                                let content = '';
                                for (const [emoji, uids] of Object.entries(msg.reactions)) {
                                    if (uids.length > 0) {
                                        hasReactions = true;
                                        content += `<div class="glass-card px-2 py-0.5 rounded-full text-xs flex items-center gap-1"><span>${emoji}</span><span>${uids.length}</span></div>`;
                                    }
                                }
                                if(hasReactions) {
                                    reactionsHTML = `<div class="flex gap-1 mt-1.5 ${isSender ? 'justify-end' : 'justify-start'}">${content}</div>`;
                                }
                            }
                            
                            const timestampHTML = !msg.isDeleted ? `
                                <div class="flex items-center justify-end gap-1 mt-1">
                                    <p class="text-xs text-gray-400">${new Date(msg.timestamp?.toDate()).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</p>
                                    ${readReceipt}
                                </div>` : '';

                            const senderNameHTML = !isSender && type === 'group' && !msg.isDeleted
                                ? `<p class="text-xs font-bold text-blue-300">${msg.senderName}</p>`
                                : '';
                            
                            const messageBoxClass = isSender 
                                ? (msg.type === 'gif' || msg.type === 'image' ? 'bg-transparent' : 'bg-blue-700')
                                : (msg.isDeleted ? 'bg-slate-800/50' : (msg.type === 'gif' || msg.type === 'image' ? 'bg-transparent' : 'bg-slate-700'));

                            messageEl.innerHTML = `
                                <div class="flex items-center gap-2 ${isSender ? 'flex-row-reverse' : 'flex-row'} w-full">
                                    ${!isSender ? `<button data-message-id="${msg.id}" class="reaction-btn self-end mb-2 opacity-0 group-hover:opacity-100 text-gray-400 hover:text-white transition-opacity"><i data-lucide="smile-plus"></i></button>` : ''}
                                    
                                    <div class="flex-shrink-1 max-w-[85%]">
                                        <div class="px-3 py-2 rounded-lg ${messageBoxClass}">
                                            ${senderNameHTML}
                                            ${messageContentHTML}
                                            ${timestampHTML}
                                        </div>
                                        ${reactionsHTML}
                                    </div>

                                    ${isSender ? `<button data-message-id="${msg.id}" class="reaction-btn self-end mb-2 opacity-0 group-hover:opacity-100 text-gray-400 hover:text-white transition-opacity"><i data-lucide="smile-plus"></i></button>` : ''}
                                </div>
                            `;
                            
                            if (canDelete) {
                                const messageBox = messageEl.querySelector('.max-w-\\[85\\%\\]');
                                const handlePressStart = (e) => {
                                    const targetElement = e.currentTarget;
                                    clearTimeout(longPressTimer);
                                    longPressTimer = setTimeout(() => {
                                        showMessageContextMenu(targetElement, chatId, msg.id, type, msg.senderId);
                                    }, 500);
                                };
                                const handlePressEnd = () => clearTimeout(longPressTimer);

                                messageBox.addEventListener('mousedown', handlePressStart);
                                messageBox.addEventListener('mouseup', handlePressEnd);
                                messageBox.addEventListener('mouseleave', handlePressEnd);
                                messageBox.addEventListener('touchstart', (e) => {
                                    e.preventDefault();
                                    handlePressStart(e);
                                });
                                messageBox.addEventListener('touchend', handlePressEnd);
                            }

                            messagesContainer.insertBefore(messageEl, messagesContainer.firstChild);

                            if (!isSender && !msg.isDeleted && (!msg.readBy || !msg.readBy.includes(currentUser.uid))) {
                                updateDoc(change.doc.ref, { readBy: arrayUnion(currentUser.uid) });
                            }
                        }
                    });

                    lucide.createIcons();
                    messagesContainer.querySelectorAll('.reaction-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            showReactionPicker(e.currentTarget, btn.dataset.messageId);
                        });
                    });
                }, (error) => {
                    console.error("Error listening to messages:", error);
                    modalContent.innerHTML = `<div class="text-center p-4"><p class="text-red-400">Fehler beim Laden der Nachrichten.</p><p class="text-gray-400 mt-2 text-sm">Dies liegt wahrscheinlich an den Firestore-Sicherheitsregeln. Sie m√ºssen Mitglied eines Chats sein, um Nachrichten lesen zu k√∂nnen.</p></div>`;
                });

                const typingIndicator = document.getElementById('typing-indicator');
                unsubscribeTypingListener = onSnapshot(chatRoomRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const typingUsers = docSnap.data().typing || {};
                        const otherTypers = Object.keys(typingUsers).filter(uid => uid !== currentUser.uid && typingUsers[uid]);
                        if (otherTypers.length > 0) {
                            typingIndicator.textContent = '... schreibt';
                        } else {
                            typingIndicator.textContent = '';
                        }
                    }
                });

                const chatInput = document.getElementById('chat-input');
                chatInput.addEventListener('keyup', (e) => handleMentionInput(e));
                chatInput.addEventListener('input', () => {
                    clearTimeout(typingTimeout);
                    updateDoc(chatRoomRef, { [`typing.${currentUser.uid}`]: true }).catch(err => console.log("Typing update failed, doc may not exist yet."));
                });

                document.getElementById('chat-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    clearTimeout(typingTimeout);
                    updateDoc(chatRoomRef, { [`typing.${currentUser.uid}`]: false }).catch(err => {});
                    
                    const text = chatInput.value.trim();
                    if (text) {
                        chatInput.value = '';
                        
                        // Step 1: Create the message data object
                        const messageData = {
                            text,
                            type: 'text',
                            senderId: currentUser.uid,
                            senderName: currentUserProfile.displayName,
                            timestamp: serverTimestamp(),
                            readBy: [currentUser.uid]
                        };

                        // Step 2: Save the message
                        try {
                            await addDoc(collection(db, collectionPath), messageData);
                        } catch (error) {
                            console.error("Error sending message:", error);
                            showToast("Nachricht konnte nicht gesendet werden.", "error");
                            chatInput.value = text; // Restore text on failure
                            return; // Stop execution if message fails to save
                        }

                        // Step 3: Update unread counts for other members (best-effort)
                        try {
                            const chatDocSnap = await getDoc(chatRoomRef);
                            let membersToNotify = [];
                            if (type === 'direct') {
                                membersToNotify = chatId.split('_');
                            } else if (chatDocSnap.exists()) {
                                membersToNotify = chatDocSnap.data().members || [];
                            }

                            const batch = writeBatch(db);
                            membersToNotify.forEach(memberId => {
                                if (memberId !== currentUser.uid) {
                                    const userRef = doc(db, 'users', memberId);
                                    batch.update(userRef, { unreadChats: arrayUnion(chatId) });
                                }
                            });
                            await batch.commit();
                        } catch (error) {
                            console.warn("Could not update unread counts for other users. This might be due to security rules. The message was sent successfully.", error);
                        }
                    }
                });
            }, 300);
        };
        
        // --- Chat Management Functions ---
        const showMessageContextMenu = (targetElement, chatId, messageId, type, senderId) => {
            const menu = document.getElementById('message-context-menu');
            const deleteBtn = document.getElementById('delete-context-btn');
            const reportBtn = document.getElementById('report-context-btn');
            
            const rect = targetElement.getBoundingClientRect();
            menu.style.top = `${rect.top - menu.offsetHeight - 5}px`;
            menu.style.left = `${rect.left}px`;
            menu.classList.remove('hidden');

            const hideMenu = () => {
                menu.classList.add('hidden');
                document.removeEventListener('click', hideMenuOnClickOutside);
            }
            
            const hideMenuOnClickOutside = (event) => {
                if (!menu.contains(event.target)) {
                    hideMenu();
                }
            };
            
            deleteBtn.onclick = () => {
                hideMenu();
                showConfirmationModal('M√∂chtest du diese Nachricht wirklich l√∂schen?', () => {
                    deleteMessage(chatId, messageId, type);
                });
            };
            
            if (senderId === currentUser.uid) {
                reportBtn.classList.add('hidden');
            } else {
                reportBtn.classList.remove('hidden');
                reportBtn.onclick = () => {
                    hideMenu();
                    showReportModal(messageId, 'message', { chatId, chatType: type, senderId });
                };
            }

            setTimeout(() => document.addEventListener('click', hideMenuOnClickOutside), 0);
        };

        const deleteMessage = async (chatId, messageId, type) => {
            const collectionPath = type === 'group' ? `groups/${chatId}/messages` : `directMessages/${chatId}/messages`;
            const messageRef = doc(db, collectionPath, messageId);
            try {
                await updateDoc(messageRef, {
                    text: "Diese Nachricht wurde gel√∂scht.",
                    content: null,
                    type: 'text',
                    isDeleted: true
                });
            } catch (error) {
                console.error("Error 'deleting' message:", error);
                showToast("Nachricht konnte nicht gel√∂scht werden.", "error");
            }
        };
        
        const leaveGroup = async (groupId, groupName) => {
            showConfirmationModal(`M√∂chtest du die Gruppe "${groupName}" wirklich verlassen?`, async () => {
                showLoader("Verlasse Gruppe...");
                try {
                    const groupRef = doc(db, 'groups', groupId);
                    await updateDoc(groupRef, { members: arrayRemove(currentUser.uid) });
                    showToast(`Gruppe "${groupName}" verlassen.`, "success");
                    closeModal(genericModal);
                    renderChatsTab();
                } catch (error) {
                    showToast("Fehler beim Verlassen der Gruppe.", "error");
                } finally {
                    hideLoader();
                }
            });
        };

        const deleteGroup = async (groupId, groupName) => {
            const groupRef = doc(db, 'groups', groupId);
            const groupSnap = await getDoc(groupRef);
            if (!groupSnap.exists()) {
                showToast("Gruppe nicht gefunden.", "error");
                return;
            }
            const groupData = groupSnap.data();
            if (groupData.ownerId !== currentUser.uid && currentUserProfile.role !== 'founder') {
                showToast("Nur der Besitzer oder Gr√ºnder kann diese Gruppe l√∂schen.", "error");
                return;
            }

            showConfirmationModal(`M√∂chtest du die Gruppe "${groupName}" wirklich l√∂schen?`, async () => {
                showLoader("L√∂sche Gruppe...");
                try {
                    await updateDoc(groupRef, {
                        isDeleted: true,
                        members: []
                    });
                    showToast(`Gruppe "${groupName}" wurde gel√∂scht.`, "success");
                    closeModal(genericModal);
                    renderChatsTab();
                } catch (error) {
                    console.error("Error deleting group:", error);
                    showToast("Fehler beim L√∂schen der Gruppe.", "error");
                } finally {
                    hideLoader();
                }
            });
        };
        
        const toggleGroupPublicStatus = async (groupId, isCurrentlyPublic) => {
            const newStatus = !isCurrentlyPublic;
            showLoader("Aktualisiere Status...");
            try {
                await updateDoc(doc(db, 'groups', groupId), { isPublic: newStatus });
                showToast(`Gruppe ist nun ${newStatus ? '√∂ffentlich' : 'privat'}.`, "success");
                closeModal(genericModal); 
                openGroupChat(groupId);
            } catch (error) {
                showToast("Status konnte nicht ge√§ndert werden.", "error");
            } finally {
                hideLoader();
            }
        };

        const showInviteFriendsModal = async (groupId, currentMembers) => {
            document.getElementById('group-settings-dropdown')?.classList.add('hidden');
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            const modalHeaderActions = document.getElementById('generic-modal-header-actions');
            modalTitle.textContent = 'Freunde einladen';
            document.getElementById('generic-modal-subtitle').textContent = '';
            modalHeaderActions.innerHTML = '';
            modalContent.innerHTML = `<div id="invite-list" class="space-y-2 max-h-96 overflow-y-auto"></div>`;
            modalFooter.innerHTML = `<button id="close-invite-modal" class="btn-secondary w-full">Fertig</button>`;

            const friends = currentUserProfile.friends || [];
            if (friends.length === 0) {
                modalContent.innerHTML = `<p class="text-gray-500">Du hast keine Freunde zum Einladen.</p>`;
            } else {
                const inviteList = document.getElementById('invite-list');
                inviteList.innerHTML = '';
                for(const friendId of friends) {
                    const userDoc = await getDoc(doc(db, `users/${friendId}`));
                    if (userDoc.exists()) {
                        const friendData = userDoc.data();
                        const isAlreadyMember = currentMembers.includes(friendId);
                        const card = document.createElement('div');
                        card.className = 'glass-card p-3 flex items-center justify-between';
                        card.innerHTML = `
                            <div class="flex items-center gap-3">
                                <img src="${friendData.photoURL || `https://placehold.co/40x40/1E293B/FFFFFF?text=${friendData.displayName.charAt(0)}`}" class="w-10 h-10 rounded-full object-cover">
                                <p class="font-semibold text-white">${friendData.displayName}</p>
                            </div>
                            <button data-friend-id="${friendId}" class="invite-friend-btn btn-primary text-sm" ${isAlreadyMember ? 'disabled' : ''}>
                                ${isAlreadyMember ? 'Mitglied' : 'Einladen'}
                            </button>
                        `;
                        inviteList.appendChild(card);
                    }
                }
                inviteList.querySelectorAll('.invite-friend-btn').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        const friendId = btn.dataset.friendId;
                        await updateDoc(doc(db, 'groups', groupId), { members: arrayUnion(friendId) });
                        showToast("Freund eingeladen!", "success");
                        btn.textContent = 'Mitglied';
                        btn.disabled = true;
                    });
                });
            }

            document.getElementById('close-invite-modal').onclick = async () => {
                closeModal(genericModal);
                await openGroupChat(groupId);
            };
        };

        const showGroupMembersModal = async (groupId, ownerId) => {
            document.getElementById('group-settings-dropdown')?.classList.add('hidden');
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            const modalHeaderActions = document.getElementById('generic-modal-header-actions');
            modalTitle.textContent = 'Mitglieder verwalten';
            document.getElementById('generic-modal-subtitle').textContent = '';
            modalHeaderActions.innerHTML = '';
            modalContent.innerHTML = `<div id="member-list" class="space-y-2 max-h-96 overflow-y-auto"></div>`;
            modalFooter.innerHTML = `<button id="close-members-modal" class="btn-secondary w-full">Schlie√üen</button>`;
            
            const groupDoc = await getDoc(doc(db, 'groups', groupId));
            if (!groupDoc.exists()) return;

            const members = groupDoc.data().members || [];
            const list = document.getElementById('member-list');
            list.innerHTML = '';

            for(const memberId of members) {
                const userDoc = await getDoc(doc(db, `users/${memberId}`));
                if (userDoc.exists()) {
                    const memberData = userDoc.data();
                    const card = document.createElement('div');
                    card.className = 'glass-card p-3 flex items-center justify-between';
                    let removeButton = '';
                    let reportButton = '';
                    if (memberId !== currentUser.uid) {
                        reportButton = `<button data-id="${memberId}" data-name="${memberData.displayName}" class="report-user-btn text-yellow-400 hover:text-yellow-300 p-1"><i data-lucide="flag"></i></button>`;
                    }
                    if (currentUser.uid === ownerId && memberId !== ownerId) {
                        removeButton = `<button data-member-id="${memberId}" data-member-name="${memberData.displayName}" class="remove-member-btn btn-primary bg-red-600 hover:bg-red-500 text-sm">Entfernen</button>`;
                    }
                    card.innerHTML = `
                        <div class="flex items-center gap-3">
                            <img src="${memberData.photoURL || `https://placehold.co/40x40/1E293B/FFFFFF?text=${memberData.displayName.charAt(0)}`}" class="w-10 h-10 rounded-full object-cover">
                            <p class="font-semibold text-white">${memberData.displayName}</p>
                        </div>
                        <div class="flex items-center gap-2">
                            ${reportButton}
                            ${removeButton}
                        </div>
                    `;
                    list.appendChild(card);
                }
            }
            lucide.createIcons();
            list.querySelectorAll('.remove-member-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const memberId = btn.dataset.memberId;
                    const memberName = btn.dataset.memberName;
                    showConfirmationModal(`M√∂chtest du ${memberName} wirklich aus der Gruppe entfernen?`, async () => {
                        await updateDoc(doc(db, 'groups', groupId), { members: arrayRemove(memberId) });
                        showToast(`${memberName} wurde entfernt.`, "success");
                        showGroupMembersModal(groupId, ownerId); 
                    });
                });
            });
            list.querySelectorAll('.report-user-btn').forEach(btn => {
                btn.addEventListener('click', () => showReportModal(btn.dataset.id, 'user', { userName: btn.dataset.name }));
            });

            document.getElementById('close-members-modal').onclick = async () => {
                closeModal(genericModal);
                await openGroupChat(groupId);
            };
        };

        
        const showCallingModal = (friendName) => {
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = `Rufe ${friendName} an`;
            document.getElementById('generic-modal-subtitle').textContent = '';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `<div class="text-center p-8"><div class="loader mx-auto"></div><p class="mt-4">Verbinde...</p><p class="text-xs text-gray-500 mt-2">(Anruf-Funktion ist derzeit eine Simulation)</p></div>`;
            modalFooter.innerHTML = `<button id="end-call-btn" class="btn-primary bg-red-600 hover:bg-red-500 w-full">Anruf beenden</button>`;
            openModal(genericModal);
            document.getElementById('end-call-btn').onclick = () => closeModal(genericModal);
        };
        
        const showProfilePicModal = () => {
            document.getElementById('user-dropdown-logged-in')?.classList.add('hidden');
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Profilbild √§ndern';
            document.getElementById('generic-modal-subtitle').textContent = '';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `<div class="flex flex-col items-center"><img id="pic-preview" src="${currentUserProfile.photoURL || `https://placehold.co/128x128/1E293B/FFFFFF?text=${currentUserProfile.displayName.charAt(0)}`}" class="w-32 h-32 rounded-full object-cover mb-4 border-2 border-slate-600"><input type="file" id="pic-upload-input" class="hidden" accept="image/*"><label for="pic-upload-input" class="btn-secondary cursor-pointer">Bild ausw√§hlen</label></div>`;
            modalFooter.innerHTML = `<button id="submit-pic-upload" class="btn-primary w-full" disabled>Hochladen & Speichern</button>`;
            openModal(genericModal);
            const input = document.getElementById('pic-upload-input');
            const preview = document.getElementById('pic-preview');
            const submitBtn = document.getElementById('submit-pic-upload');
            let selectedFile = null;
            input.addEventListener('change', (e) => {
                selectedFile = e.target.files[0];
                if (selectedFile) {
                    const reader = new FileReader();
                    reader.onload = (event) => { preview.src = event.target.result; };
                    reader.readAsDataURL(selectedFile);
                    submitBtn.disabled = false;
                }
            });
            submitBtn.addEventListener('click', async () => {
                if (!selectedFile) return;
                if (!currentUser) {
                    showToast("Sie m√ºssen angemeldet sein, um ein Bild hochzuladen.", "error");
                    return;
                }
                
                modalContent.innerHTML = `
                    <div id="upload-progress-container">
                        <p id="upload-status-text" class="text-center mb-2">Lade Profilbild hoch...</p>
                        <div class="w-full bg-slate-700 rounded-full h-4"><div id="progress-bar" class="bg-blue-600 h-4 rounded-full transition-all duration-300" style="width: 0%"></div></div>
                        <p id="progress-percentage" class="text-center text-sm mt-1">0%</p>
                    </div>`;
                modalFooter.innerHTML = '';
                
                try {
                    await auth.currentUser.getIdToken(true);
                    const fileRef = storageRef(storage, `profilePictures/${currentUser.uid}`);
                    const metadata = { contentType: selectedFile.type };
                    const uploadTask = uploadBytesResumable(fileRef, selectedFile, metadata);

                    uploadTask.on('state_changed', 
                        (snapshot) => {
                            const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                            const progressBar = document.getElementById('progress-bar');
                            const progressPercentage = document.getElementById('progress-percentage');
                            if (progressBar) progressBar.style.width = progress + '%';
                            if (progressPercentage) progressPercentage.textContent = Math.round(progress) + '%';
                        }, 
                        (error) => {
                            console.error("Upload failed", error);
                            const progressContainer = document.getElementById('upload-progress-container');
                            if (progressContainer) {
                                let errorMessage = "Fehler beim Hochladen.";
                                if (error.code === 'storage/unauthorized') {
                                    errorMessage = "Berechtigungsfehler. Bitte erneut anmelden und sicherstellen, dass die Storage-Regeln korrekt sind.";
                                }
                                progressContainer.innerHTML = `<p class="text-red-400 text-center p-4">${errorMessage}</p>`;
                            }
                        }, 
                        async () => {
                            try {
                                const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                                await updateDoc(doc(db, 'users', currentUser.uid), { photoURL: downloadURL });
                                await updateProfile(auth.currentUser, { photoURL: downloadURL });
                                showToast('Profilbild erfolgreich aktualisiert!', 'success');
                                closeModal(genericModal);
                            } catch (e) {
                                console.error("Error updating profile:", e);
                                showToast('Fehler beim Aktualisieren des Profils.', 'error');
                                closeModal(genericModal);
                            }
                        }
                    );
                } catch(error) {
                    console.error("Token refresh or upload failed:", error);
                    showToast('Authentifizierung fehlgeschlagen oder Upload-Fehler.', 'error');
                    closeModal(genericModal);
                }
            });
        };
        
        const showNotesModal = () => {
            document.getElementById('user-dropdown-logged-in')?.classList.add('hidden');
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Meine Notizen';
            document.getElementById('generic-modal-subtitle').textContent = '';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `<div id="notes-list" class="space-y-2"></div>`;
            modalFooter.innerHTML = `<form id="add-note-form" class="flex gap-2"><input id="note-input" class="flex-grow p-2 bg-slate-800 border border-slate-700 rounded-lg" placeholder="Neue Notiz..." autocomplete="off"><button type="submit" class="btn-primary"><i data-lucide="plus"></i></button></form>`;
            lucide.createIcons();
            openModal(genericModal);
            const notesCollectionRef = collection(db, `users/${currentUser.uid}/notes`);
            const q = query(notesCollectionRef, orderBy('createdAt', 'desc'));
            onSnapshot(q, (snapshot) => {
                const list = document.getElementById('notes-list');
                if (!list) return;
                list.innerHTML = '';
                if(snapshot.empty) { list.innerHTML = `<p class="text-center text-gray-500 p-4">Keine Notizen vorhanden.</p>`; return; }
                snapshot.forEach(doc => {
                    const note = { id: doc.id, ...doc.data() };
                    const noteEl = document.createElement('div');
                    noteEl.className = 'p-3 glass-card rounded-lg flex justify-between items-center';
                    noteEl.innerHTML = `<p>${note.text}</p><button data-id="${note.id}" class="delete-note-btn text-red-500 hover:text-red-400"><i data-lucide="trash-2"></i></button>`;
                    list.appendChild(noteEl);
                });
                list.querySelectorAll('.delete-note-btn').forEach(btn => { btn.addEventListener('click', () => { const noteId = btn.dataset.id; deleteDoc(doc(db, `users/${currentUser.uid}/notes`, noteId)); }); });
                lucide.createIcons();
            });
            document.getElementById('add-note-form').addEventListener('submit', async (e) => { e.preventDefault(); const input = document.getElementById('note-input'); const text = input.value.trim(); if (text) { input.value = ''; await addDoc(notesCollectionRef, { text, createdAt: serverTimestamp() }); } });
        };

        const showSettingsModal = () => {
            document.getElementById('user-dropdown-logged-in')?.classList.add('hidden');
            const modalTitle = document.getElementById('generic-modal-title');
            const modalContent = document.getElementById('generic-modal-content');
            const modalFooter = document.getElementById('generic-modal-footer');
            modalTitle.textContent = 'Einstellungen';
            document.getElementById('generic-modal-subtitle').textContent = '';
            document.getElementById('generic-modal-header-actions').innerHTML = '';
            modalContent.innerHTML = `
                <div class="space-y-4">
                    <button id="change-name-btn" class="w-full text-left p-3 glass-card hover:bg-slate-700 rounded-lg">Anzeigename √§ndern</button>
                    <button id="change-password-btn" class="w-full text-left p-3 glass-card hover:bg-slate-700 rounded-lg">Passwort √§ndern</button>
                    <div class="flex justify-between items-center p-3 glass-card rounded-lg">
                        <label for="notifications-toggle">Benachrichtigungston</label>
                        <input type="checkbox" id="notifications-toggle" class="toggle-checkbox">
                    </div>
                    <div class="flex justify-between items-center p-3 glass-card rounded-lg">
                        <label for="browser-notifications-toggle">Browser-Benachrichtigungen</label>
                        <input type="checkbox" id="browser-notifications-toggle" class="toggle-checkbox">
                    </div>
                </div>
            `;
            modalFooter.innerHTML = '';
            openModal(genericModal);

            document.getElementById('change-name-btn').addEventListener('click', showChangeNameModal);
            document.getElementById('change-password-btn').addEventListener('click', showChangePasswordModal);
            
            const notifToggle = document.getElementById('notifications-toggle');
            notifToggle.checked = currentUserProfile.notificationsEnabled ?? true;
            notifToggle.addEventListener('change', toggleNotifications);

            const browserNotifToggle = document.getElementById('browser-notifications-toggle');
            browserNotifToggle.checked = currentUserProfile.browserNotificationsEnabled ?? true;
            browserNotifToggle.addEventListener('change', toggleBrowserNotifications);
        };

        const showChangeNameModal = () => {
            closeModal(genericModal);
            setTimeout(() => { 
                const modalTitle = document.getElementById('generic-modal-title');
                const modalContent = document.getElementById('generic-modal-content');
                const modalFooter = document.getElementById('generic-modal-footer');
                modalTitle.textContent = 'Anzeigename √§ndern';
                document.getElementById('generic-modal-subtitle').textContent = '';
                modalContent.innerHTML = `
                    <div>
                        <label for="change-displayname-input" class="block text-sm font-medium text-gray-300 mb-1">Neuer Anzeigename</label>
                        <input type="text" id="change-displayname-input" value="${currentUserProfile.displayName}" class="w-full p-3 bg-slate-800 border border-slate-700 rounded-lg">
                    </div>
                `;
                modalFooter.innerHTML = `<button id="save-settings-btn" class="btn-primary">√Ñnderungen speichern</button>`;
                openModal(genericModal);

                document.getElementById('save-settings-btn').onclick = async () => {
                    const newName = document.getElementById('change-displayname-input').value.trim();
                    if (newName.length < 3) {
                        showToast("Der Anzeigename muss mindestens 3 Zeichen lang sein.", "error");
                        return;
                    }
                    if (newName === currentUserProfile.displayName) {
                        closeModal(genericModal);
                        return;
                    }
                    showLoader("Speichere...");
                    try {
                        await updateProfile(auth.currentUser, { displayName: newName });
                        await updateDoc(doc(db, 'users', currentUser.uid), { displayName: newName });
                        showToast("Anzeigename erfolgreich ge√§ndert!", "success");
                        closeModal(genericModal);
                    } catch (error) {
                        console.error("Error updating display name:", error);
                        showToast("Fehler beim √Ñndern des Namens.", "error");
                    } finally {
                        hideLoader();
                    }
                };
            }, 350);
        };

        const showChangePasswordModal = () => {
            closeModal(genericModal);
            setTimeout(() => {
                const modalTitle = document.getElementById('generic-modal-title');
                const modalContent = document.getElementById('generic-modal-content');
                const modalFooter = document.getElementById('generic-modal-footer');
                modalTitle.textContent = 'Passwort √§ndern';
                document.getElementById('generic-modal-subtitle').textContent = '';
                modalContent.innerHTML = `<p class="text-gray-300">Wir senden dir eine E-Mail an <strong>${currentUser.email}</strong>, mit der du dein Passwort zur√ºcksetzen kannst.</p>`;
                modalFooter.innerHTML = `<button id="send-password-reset-btn" class="btn-primary">E-Mail senden</button>`;
                openModal(genericModal);

                document.getElementById('send-password-reset-btn').onclick = async () => {
                    showLoader("Sende E-Mail...");
                    try {
                        await sendPasswordResetEmail(auth, currentUser.email);
                        showToast("E-Mail zum Zur√ºcksetzen des Passworts wurde gesendet. Bitte √ºberpr√ºfe dein Postfach.", "success");
                        closeModal(genericModal);
                    } catch (error) {
                        console.error("Password reset error:", error);
                        showToast("Fehler beim Senden der E-Mail.", "error");
                    } finally {
                        hideLoader();
                    }
                };
            }, 350);
        };
        
        const toggleNotifications = async (e) => {
            const enabled = e.target.checked;
            try {
                await updateDoc(doc(db, 'users', currentUser.uid), { notificationsEnabled: enabled });
                if (enabled) {
                    showToast("Benachrichtigungst√∂ne aktiviert!", "success");
                } else {
                    showToast("Benachrichtigungst√∂ne deaktiviert.", "info");
                }
            } catch (error) {
                showToast("Fehler beim Speichern der Einstellung.", "error");
            }
        };

        const showNotificationSound = () => {
            if (!currentUserProfile?.notificationsEnabled) return;
            
            if (!notificationSound) {
                notificationSound = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 }
                }).toDestination();
            }
            notificationSound.triggerAttackRelease("C5", "8n");
        };
        
        // --- EMOJI, GIF & AUDIO FUNCTIONS ---

        const togglePicker = (type, buttonElement) => {
            if (activePicker === type) {
                hidePicker();
            } else {
                activePicker = type;
                pickerPopover.innerHTML = '';
                pickerPopover.classList.remove('hidden');

                if (type === 'emoji') {
                    renderEmojiPicker();
                } else if (type === 'gif') {
                    renderGifPicker();
                }
            }
        };

        const hidePicker = () => {
            if (!pickerPopover.classList.contains('hidden')) {
                pickerPopover.classList.add('hidden');
                activePicker = null;
            }
        };

        const renderEmojiPicker = () => {
            const emojiPicker = document.createElement('emoji-picker');
            emojiPicker.className = 'w-full h-80';
            pickerPopover.appendChild(emojiPicker);
            emojiPicker.addEventListener('emoji-click', e => {
                const chatInput = document.getElementById('chat-input');
                chatInput.value += e.detail.unicode;
            });
        };
        
        const renderGifPicker = () => {
            pickerPopover.innerHTML = `
                <div class="p-2">
                    <input id="gif-search-input" type="text" placeholder="GIPHY durchsuchen..." class="w-full p-2 bg-slate-800 border border-slate-700 rounded-lg mb-2">
                    <div id="gif-results" class="grid grid-cols-3 gap-2 h-72 overflow-y-auto">
                        <div class="col-span-3 text-center text-gray-400 pt-8">Suche nach GIFs...</div>
                    </div>
                </div>
            `;
            const searchInput = document.getElementById('gif-search-input');
            let searchTimeout;
            searchInput.addEventListener('keyup', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    searchGifs(searchInput.value);
                }, 500);
            });
            searchGifs('');
        };

        const searchGifs = async (query) => {
            const resultsContainer = document.getElementById('gif-results');
            if (!resultsContainer) return;

            if (GIPHY_API_KEY === 'DEIN_GIPHY_API_SCHL√úSSEL') {
                resultsContainer.innerHTML = `<div class="col-span-3 text-center text-red-400 p-4">Bitte f√ºge einen g√ºltigen Giphy API-Schl√ºssel im Skript hinzu, um GIFs zu suchen.</div>`;
                return;
            }

            resultsContainer.innerHTML = `<div class="col-span-3 flex justify-center pt-8"><div class="loader"></div></div>`;
            
            const endpoint = query ? `search?q=${encodeURIComponent(query)}` : 'trending?';
            const url = `https://api.giphy.com/v1/gifs/${endpoint}&api_key=${GIPHY_API_KEY}&limit=30`;

            try {
                const response = await fetch(url);
                const json = await response.json();
                resultsContainer.innerHTML = '';
                if (json.data && json.data.length > 0) {
                    json.data.forEach(gif => {
                        const img = document.createElement('img');
                        img.src = gif.images.fixed_height_small.url;
                        img.alt = gif.title;
                        img.className = 'w-full h-full object-cover rounded-md cursor-pointer hover:opacity-80';
                        img.onclick = () => sendGifMessage(gif.images.original.url, activeChatId);
                        resultsContainer.appendChild(img);
                    });
                } else {
                    resultsContainer.innerHTML = `<div class="col-span-3 text-center text-gray-400 pt-8">Keine Ergebnisse gefunden.</div>`;
                }
            } catch (error) {
                console.error("Error fetching GIFs:", error);
                resultsContainer.innerHTML = `<div class="col-span-3 text-center text-red-400 p-4">Fehler beim Laden der GIFs.</div>`;
            }
        };

        const sendGifMessage = async (gifUrl, chatId) => {
            if (!chatId || !activeChatType) return;
            const collectionPath = activeChatType === 'group' ? `groups/${chatId}/messages` : `directMessages/${chatId}/messages`;
            try {
                await addDoc(collection(db, collectionPath), {
                    type: 'gif',
                    content: gifUrl,
                    text: '[GIF]',
                    senderId: currentUser.uid,
                    senderName: currentUserProfile.displayName,
                    timestamp: serverTimestamp(),
                    readBy: [currentUser.uid]
                });

                const chatDocRef = doc(db, activeChatType === 'group' ? 'groups' : 'directMessages', chatId);
                const chatDocSnap = await getDoc(chatDocRef);
                if (chatDocSnap.exists()) {
                    const members = chatDocSnap.data().members;
                    const batch = writeBatch(db);
                    members.forEach(memberId => {
                        if (memberId !== currentUser.uid) {
                            const userRef = doc(db, 'users', memberId);
                            batch.update(userRef, { unreadChats: arrayUnion(chatId) });
                        }
                    });
                    await batch.commit();
                }

                hidePicker();
            } catch (error) {
                console.error("Error sending GIF message:", error);
                showToast("GIF konnte nicht gesendet werden.", "error");
            }
        };

        const handleRecordButtonClick = () => {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        };

        const startRecording = async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                isRecording = true;
                audioChunks = [];
                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const audioFileName = `audio_${Date.now()}.webm`;
                    const fileRef = storageRef(storage, `chatAudio/${activeChatId}/${audioFileName}`);
                    
                    showLoader('Lade Sprachnachricht hoch...');
                    try {
                        const uploadTask = uploadBytesResumable(fileRef, audioBlob);
                        await uploadTask;
                        const downloadURL = await getDownloadURL(fileRef);
                        await sendAudioMessage(downloadURL, activeChatId);
                    } catch (error) {
                        console.error("Error uploading audio:", error);
                        showToast("Fehler beim Hochladen der Sprachnachricht.", "error");
                    } finally {
                        hideLoader();
                    }
                };

                mediaRecorder.start();
                const micBtn = document.getElementById('mic-btn');
                if (micBtn) {
                    micBtn.classList.add('bg-red-600', 'recording-indicator');
                }
            } catch (error) {
                console.error("Error accessing microphone:", error);
                showToast("Mikrofonzugriff verweigert oder nicht verf√ºgbar.", "error");
            }
        };

        const stopRecording = () => {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                const micBtn = document.getElementById('mic-btn');
                if (micBtn) {
                    micBtn.classList.remove('bg-red-600', 'recording-indicator');
                }
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
        };

        const sendAudioMessage = async (audioUrl, chatId) => {
            if (!chatId || !activeChatType) return;
            const collectionPath = activeChatType === 'group' ? `groups/${chatId}/messages` : `directMessages/${chatId}/messages`;
            try {
                await addDoc(collection(db, collectionPath), {
                    type: 'audio',
                    content: audioUrl,
                    text: '[Sprachnachricht]',
                    senderId: currentUser.uid,
                    senderName: currentUserProfile.displayName,
                    timestamp: serverTimestamp(),
                    readBy: [currentUser.uid]
                });

                const chatDocRef = doc(db, activeChatType === 'group' ? 'groups' : 'directMessages', chatId);
                const chatDocSnap = await getDoc(chatDocRef);
                if (chatDocSnap.exists()) {
                    const members = chatDocSnap.data().members;
                    const batch = writeBatch(db);
                    members.forEach(memberId => {
                        if (memberId !== currentUser.uid) {
                            const userRef = doc(db, 'users', memberId);
                            batch.update(userRef, { unreadChats: arrayUnion(chatId) });
                        }
                    });
                    await batch.commit();
                }
            } catch (error) {
                console.error("Error sending audio message:", error);
                showToast("Sprachnachricht konnte nicht gesendet werden.", "error");
            }
        };
        
        // --- MENTION & REACTION FUNCTIONS ---
        const handleMentionInput = (event) => {
            const input = event.target;
            const popover = document.getElementById('mention-popover');
            
            if (activeChatType !== 'group' || !activeChatGroupData.memberDetails) {
                popover.classList.add('hidden');
                return;
            }

            const text = input.value;
            const cursorPos = input.selectionStart;
            const atMatch = text.slice(0, cursorPos).match(/@(\w*)$/);

            if (atMatch) {
                const searchTerm = atMatch[1].toLowerCase();
                const members = Object.values(activeChatGroupData.memberDetails);
                const suggestions = members.filter(m => 
                    m.id !== currentUser.uid && m.displayName.toLowerCase().includes(searchTerm)
                );

                if (suggestions.length > 0) {
                    popover.innerHTML = suggestions.map(s => 
                        `<button class="mention-suggestion w-full text-left px-3 py-1.5 hover:bg-slate-700 rounded-md" data-name="${s.displayName}">${s.displayName}</button>`
                    ).join('');
                    
                    const inputRect = input.getBoundingClientRect();
                    popover.style.bottom = `${window.innerHeight - inputRect.top}px`;
                    popover.style.left = `${inputRect.left}px`;
                    popover.classList.remove('hidden');

                    popover.querySelectorAll('.mention-suggestion').forEach(btn => {
                        btn.onclick = () => {
                            const mentionName = btn.dataset.name;
                            const newText = text.slice(0, atMatch.index) + `@${mentionName} ` + text.slice(cursorPos);
                            input.value = newText;
                            input.focus();
                            popover.classList.add('hidden');
                        };
                    });
                } else {
                    popover.classList.add('hidden');
                }
            } else {
                popover.classList.add('hidden');
            }
        };

        const showReactionPicker = (targetElement, messageId) => {
            const picker = document.getElementById('reaction-picker-popover');
            picker.innerHTML = PREDEFINED_REACTIONS.map(emoji => 
                `<button class="reaction-emoji-btn text-2xl hover:scale-125 transition-transform" data-emoji="${emoji}">${emoji}</button>`
            ).join('');

            const rect = targetElement.getBoundingClientRect();
            picker.style.top = `${rect.top - picker.offsetHeight - 5}px`;
            picker.style.left = `${rect.left}px`;
            picker.classList.remove('hidden');

            picker.querySelectorAll('.reaction-emoji-btn').forEach(btn => {
                btn.onclick = () => {
                    handleReaction(messageId, btn.dataset.emoji);
                    picker.classList.add('hidden');
                };
            });

            const hidePickerOnClickOutside = (event) => {
                if (!picker.contains(event.target) && !targetElement.contains(event.target)) {
                    picker.classList.add('hidden');
                    document.removeEventListener('click', hidePickerOnClickOutside);
                }
            };
            setTimeout(() => document.addEventListener('click', hidePickerOnClickOutside), 0);
        };

        const handleReaction = async (messageId, emoji) => {
            if (!activeChatId || !activeChatType) return;
            const collectionPath = activeChatType === 'group' ? `groups/${activeChatId}/messages` : `directMessages/${activeChatId}/messages`;
            const messageRef = doc(db, collectionPath, messageId);

            try {
                const messageSnap = await getDoc(messageRef);
                if (!messageSnap.exists()) return;

                const reactions = messageSnap.data().reactions || {};
                const uidsForEmoji = reactions[emoji] || [];

                if (uidsForEmoji.includes(currentUser.uid)) {
                    await updateDoc(messageRef, {
                        [`reactions.${emoji}`]: arrayRemove(currentUser.uid)
                    });
                } else {
                    await updateDoc(messageRef, {
                        [`reactions.${emoji}`]: arrayUnion(currentUser.uid)
                    });
                }
            } catch (error) {
                console.error("Error handling reaction:", error);
                showToast("Reaktion konnte nicht verarbeitet werden.", "error");
            }
        };
        
        // --- MAINTENANCE MODE & NOTIFICATION FUNCTIONS ---
        const renderMaintenanceScreen = () => {
            appContainer.classList.add('hidden');
            appContainer.classList.remove('flex');
            maintenanceScreen.classList.remove('hidden');
            maintenanceScreen.classList.add('flex');
        };

        const renderSiteSettings = async () => {
            const adminContentArea = document.getElementById('admin-content-area');
            if (!adminContentArea) return;
            adminContentArea.innerHTML = '<div class="loader"></div>';

            const metadataRef = doc(db, `app-metadata/${appId}`);
            const metadataSnap = await getDoc(metadataRef);
            const metadata = metadataSnap.exists() ? metadataSnap.data() : { maintenanceEnabled: false, maintenanceWhitelist: [] };

            let whitelistHtml = '';
            if (metadata.maintenanceEnabled) {
                const usersRef = collection(db, "users");
                const usersSnap = await getDocs(usersRef);
                const allUsers = usersSnap.docs.map(d => ({id: d.id, ...d.data()}));
                
                let userListHtml = '';
                allUsers.forEach(user => {
                    if (user.role === 'founder') return;
                    const isWhitelisted = metadata.maintenanceWhitelist.includes(user.id);
                    userListHtml += `
                        <div class="glass-card p-3 flex items-center justify-between">
                            <div class="flex items-center gap-3">
                                <img src="${user.photoURL || `https://placehold.co/40x40/1E293B/FFFFFF?text=${user.displayName.charAt(0)}`}" class="w-10 h-10 rounded-full object-cover">
                                <span>${user.displayName}</span>
                            </div>
                            <button data-uid="${user.id}" class="toggle-whitelist-btn ${isWhitelisted ? 'bg-red-600 hover:bg-red-500' : 'bg-green-600 hover:bg-green-500'} btn-primary text-sm">${isWhitelisted ? 'Entfernen' : 'Hinzuf√ºgen'}</button>
                        </div>
                    `;
                });

                whitelistHtml = `
                    <div class="mt-6">
                        <h3 class="text-lg font-semibold mb-2">Whitelist f√ºr Wartungsmodus</h3>
                        <div class="space-y-2 max-h-64 overflow-y-auto">${userListHtml}</div>
                    </div>
                `;
            }

            adminContentArea.innerHTML = `
                <div>
                    <h3 class="text-lg font-semibold">Wartungsmodus</h3>
                    <div class="flex items-center justify-between p-3 glass-card rounded-lg mt-2">
                        <span>Seite f√ºr alle Nutzer (au√üer Gr√ºnder) sperren</span>
                        <button id="toggle-maintenance-btn" class="${metadata.maintenanceEnabled ? 'bg-red-600 hover:bg-red-500' : 'bg-green-600 hover:bg-green-500'} btn-primary">${metadata.maintenanceEnabled ? 'Deaktivieren' : 'Aktivieren'}</button>
                    </div>
                    ${whitelistHtml}
                </div>
            `;
            
            adminContentArea.querySelectorAll('.toggle-whitelist-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const uid = btn.dataset.uid;
                    const metadataRef = doc(db, `app-metadata/${appId}`);
                    const metadataSnap = await getDoc(metadataRef);
                    const currentWhitelist = metadataSnap.data().maintenanceWhitelist || [];
                    
                    if (currentWhitelist.includes(uid)) {
                        await updateDoc(metadataRef, { maintenanceWhitelist: arrayRemove(uid) });
                        showToast('Nutzer von Whitelist entfernt.', 'info');
                    } else {
                        await updateDoc(metadataRef, { maintenanceWhitelist: arrayUnion(uid) });
                        showToast('Nutzer zu Whitelist hinzugef√ºgt.', 'success');
                    }
                    renderSiteSettings(); // Refresh the view
                });
            });

            document.getElementById('toggle-maintenance-btn').addEventListener('click', async () => {
                const metadataRef = doc(db, `app-metadata/${appId}`);
                const metadataSnap = await getDoc(metadataRef);
                const isEnabled = metadataSnap.data().maintenanceEnabled || false;
                await setDoc(metadataRef, { maintenanceEnabled: !isEnabled }, { merge: true });
                showToast(`Wartungsmodus ${!isEnabled ? 'aktiviert' : 'deaktiviert'}.`, 'info');
                renderSiteSettings();
            });
        };
        
        const showBrowserNotification = (title, body) => {
            new Notification(title, { body, icon: './favicon.ico' }); // Assuming you have a favicon
        };

        const toggleBrowserNotifications = async (e) => {
            const enabled = e.target.checked;
            const userRef = doc(db, 'users', currentUser.uid);

            if (enabled) {
                if (Notification.permission === 'granted') {
                    await updateDoc(userRef, { browserNotificationsEnabled: true });
                    showToast("Browser-Benachrichtigungen aktiviert.", "success");
                } else if (Notification.permission === 'denied') {
                    showToast("Browser-Benachrichtigungen sind blockiert. Bitte in den Browsereinstellungen √§ndern.", "error");
                    e.target.checked = false;
                } else {
                    const permission = await Notification.requestPermission();
                    if (permission === 'granted') {
                        await updateDoc(userRef, { browserNotificationsEnabled: true });
                        showToast("Browser-Benachrichtigungen aktiviert.", "success");
                    } else {
                        showToast("Berechtigung f√ºr Benachrichtigungen nicht erteilt.", "info");
                        e.target.checked = false;
                    }
                }
            } else {
                await updateDoc(userRef, { browserNotificationsEnabled: false });
                showToast("Browser-Benachrichtigungen deaktiviert.", "info");
            }
        };


        // --- INITIALIZATION ---
        window.onload = () => {
            lucide.createIcons();
            if (!app) {
                hideLoader();
                return;
            }
            showLoader('Lade App...');
        };
        
        // --- Event Listeners for Modals ---
        document.getElementById('close-auth-modal').addEventListener('click', () => closeModal(authModal));
        document.getElementById('close-chats-friends-modal').addEventListener('click', () => {
            closeModal(chatsFriendsModal);
            Object.values(friendsStatusUnsubscribers).forEach(unsub => unsub());
            friendsStatusUnsubscribers = {};
        });
        
        document.getElementById('close-generic-modal').addEventListener('click', () => {
            const wasChatOpen = activeChatId !== null;

            if (unsubscribeChatListener) unsubscribeChatListener();
            if (unsubscribeTypingListener) unsubscribeTypingListener();
            if (unsubscribeFriendStatusListener) unsubscribeFriendStatusListener();
            hidePicker();
            
            activeChatId = null;
            activeChatType = null;
            activeChatGroupData = null;

            closeModal(genericModal);

            if(wasChatOpen) {
                setTimeout(() => {
                    openChatsAndFriendsModal();
                }, 300);
            }
        });

        document.addEventListener('click', (e) => {
            if (activePicker && !pickerPopover.contains(e.target) && !e.target.closest('#emoji-btn') && !e.target.closest('#gif-btn')) {
                hidePicker();
            }
            const mentionPopover = document.getElementById('mention-popover');
            if(!mentionPopover.classList.contains('hidden') && !mentionPopover.contains(e.target) && e.target.id !== 'chat-input') {
                mentionPopover.classList.add('hidden');
            }
        });

    </script>
</body>
</html>